[TOC]



# 数据库

##### 关系型数据库与非关系型数据库

**一、关系型数据库**

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210422104606.png)

关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织

优点：

- 易于维护：都是表结构，格式一致
- 使用方便：SQL语言通用，可用于复杂查询
- 复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询

缺点：

- 读写性能比较差，尤其是海量数据的高效率读写
- 固定的表结构，灵活的欠缺
- 高并发读写需求，传统关系型数据库来说，硬盘I/O是个很大的瓶颈

**二、非关系型数据库**

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210422105143.png)

非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。
优点：

- 格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。
- 速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；
- 高扩展性；
- 成本低：nosql数据库部署简单，基本都是开源软件。

缺点：

- 不提供sql支持，学习和使用成本较高；
- 无事务处理；
- 数据结构相对复杂，复杂查询方面稍欠。

##### 数据库中的主键、超键、候选键、外键是什么？

- **超键**：在关系中能唯一标识**元组的属性集**称为关系模式的超键
- **候选键**：不含有**多余属性的超键**称为候选键。也就是在候选键中，若再删除属性，就不是键了！
- **主键**：**用户选作元组标识的一个候选键程序主键**
- **外键**：如果关系模式**R中属性K是其它模式的主键**，那么**k在模式R中称为外键**。

**举例**：

| 学号     | 姓名   | 性别 | 年龄 | 系别   | 专业     |
| :------- | :----- | :--- | :--- | :----- | :------- |
| 20020612 | 李辉   | 男   | 20   | 计算机 | 软件开发 |
| 20060613 | 张明   | 男   | 18   | 计算机 | 软件开发 |
| 20060614 | 王小玉 | 女   | 19   | 物理   | 力学     |
| 20060615 | 李淑华 | 女   | 17   | 生物   | 动物学   |
| 20060616 | 赵静   | 男   | 21   | 化学   | 食品化学 |
| 20060617 | 赵静   | 女   | 20   | 生物   | 植物学   |

1. 超键：于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(`学号`，`性别`)，(`学号`，`年龄`)
2. 候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。
3. 主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。
4. 外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。

**主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。**

##### SQL基本指令

###### 基础查询指令

> SELECT 查询列表 from 表名

查询单个字段、多个字段和所有字段

```sql
SELECT Last_name FROM employees;
SELECT Last_name,salary,email FROM employees;
SELECT * FROM employees;
```

起别名，将查询的字段以别名的方式呈现

```sql
#方式一
SELECT 100%98 AS 结果;
SELECT last_name AS 姓, first_name AS 名 FROM employees;
#方式二
SELECT last_name 姓, first_name 名 FROM employees;
#案例：查询salary，显示结果为out put 其中out为关键字
SELECT salary AS "out put" FROM employees;
```

去重

```sql
#案例：查询员工表中涉及到的所有的部门编号
SELECT DISTINCT department_id FROM employees;
```

###### 条件查询指令

```java
/*
语法： 
     select
           查询列表
     from  
           表名
     where 
           筛选条件;
  分类：
      一、按条件表达式筛选
      条件运算符：> < = !=  <> <= >=
      二、按逻辑表达式筛选
      逻辑运算符：&& || !
                  and or not
      三、模糊查询
               like
               between and
               in
               is null
 */

# 一、按条件表达式筛选

#案例1：查询工资>12000的员工信息
SELECT
      *
FROM
      employees
WHERE 
      salary>12000;
      
#案例2：查询部门编号不等于 90的员工名和部门编号
SELECT last_name, department_id 
FROM employees 
WHERE department_id <>90;

# 二、按逻辑表达式筛选

#案例1：查询工资在10000到20000之间的员工名、工资以及奖金
SELECT last_name,salary,commission_pct		
FROM employees;
WHERE salary>=10000 AND salary<=20000;

#三、模糊查询
#1.like 一般和通配符搭配使用 %任意多个字符，包含0个  _ 任意一个字符
#案例1：查询员工名中包含字符a的员工信息
SELECT *
FROM employees
WHERE last_name LIKE '%a%';

# 案例2：查询员工名中第三个字符为e，第五个字符为a的员工名

SELECT last_name,salary
FROM employees
WHERE last_name LIKE '__e_a%';

#案例3：查询员工名中第二个字符为_的员工名
SELECT last_name
FROM employees
WHERE last_name LIKE '_\_%';

#2.between and 包含临界值，先小后大

#案例1：查询员工编号在100到120之间的员工信息
SELECT *
FROM employees
WHERE employee_id BETWEEN 100 AND 120;

#3. in 
#案例：查询员工的公种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号
SELECT last_name, job_id
FROM employees
WHERE job_id IN ('IT_PROG','AD_VP','AD_PRES');

#4. is null   =与<>不能判断null
#案例1：查询没有奖金的员工名和奖金率
SELECT last_name,commission_pct
FROM employees
WHERE commission_pct IS NULL;


#安全等于 <=>
#案例1：查询没有奖金的员工名和奖金率
SELECT last_name,commission_pct
FROM employees
WHERE commission_pct <=> NULL;

#案例12：查询工资为12000的员工信息
SELECT
      *
FROM
      employees
WHERE 
      salary <=> 12000;
```

###### 排序查询

```sql
/*
select 查询列表
from   表
   【where 筛选条件】
order by 排序列表 【asc|desc】
          asc升序，desc降序，默认升序

*/

#案:1：查询员工信息，要求工资从高到低排序
SELECT * FROM employees ORDER BY salary DESC;

#案例2：查询部门编号>=90的员工信息，按入职时间先后排序
SELECT * FROM employees
WHERE department_id >=90
ORDER BY hiredate ASC;

#案例3：按年薪的高低显示员工的信息和年薪【按表达式排序】
SELECT *,salary*12*(1+IFNULL(commission_pct,0))  年薪
FROM employees
ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;

#案例4：按年薪的高低显示员工的信息和年薪【按别名排序】
SELECT *,salary*12*(1+IFNULL(commission_pct,0))  年薪
FROM employees
ORDER BY 年薪 DESC;

#案例5：按姓名的长度显示员工的姓名和工资【按函数排序】
SELECT LENGTH(last_name) 字节长度,last_name,salary
FROM employees
ORDER BY LENGTH(last_name) DESC;

#案例6：查询员工信息，要求先按员工工资排序，再按员工编号排序【多字段排序】
SELECT *
FROM employees
ORDER BY salary ASC, employee_id DESC;

```

###### 单行函数练习

```sql
#进阶4：常见函数
/*
分类：
	1、单行函数
	concat、length、ifnull等
	2、分组函数
	做统计使用，又称为统计函数
*/

#一、字符函数

#1. length  获取参数值得字节个数
SELECT LENGTH('john');

#2. concat 拼接字符串
SELECT CONCAT(last_name,'_',first_name) FROM employees;

#3. upper、lower
SELECT UPPER('john');
SELECT LOWER('joHN');
#将姓大写，名小写
SELECT CONCAT(UPPER(last_name),'_',LOWER(first_name)) FROM employees;

#4. substr、substring 索引从1开始
#截取从指定索引处后面所有字符
SELECT SUBSTR('jdshgshfgh',7) out_put;

#截取从指定索引处指定字符长度的字符
SELECT SUBSTR('jsdfghsdhgdf',2,4);

#5. instr
#返回子串第一次出现的索引，如果找不到返回0
SELECT INSTR('nasdhfv','sdh') out_put;

#6. trim 去掉前后的指定字符
SELECT TRIM('     safd');
SELECT TRIM('a' FROM 'aaaasdfgfdgaaaaa') put;

#7.lpad 用指定的字符实现左填充指定长度
SELECT LPAD('fsdgd',10,'*') AS out_put;

#8.rpad 用指定的字符实现右填充指定长度
SELECT RPAD('fs',10,'*') AS out_put;

#9.repalce 替换
SELECT REPLACE('sdsdsdsd','s','a') put;


# 二、数学函数
#1.round 四舍五入
SELECT ROUND(1.65);
SELECT ROUND(1.56723,2);

#2. cell 向上取整,返回>=该参数的最小整数
SELECT CEIL(1.23);

#3. floor 向下取整，返回<=该参数的最大整数
SELECT FLOOR(-9.99);

#truncate 截断
SELECT TRUNCATE(1.6999,1);

#mod 取余 mod(a,b):a-a/b*b
SELECT MOD(10,3);
SELECT 10%3;

#三、日期函数
#now 返回当前系统日期加时间
SELECT NOW();

#curdate 返回当前系统日期。不包含时间
SELECT CURDATE();

#curtime 返回当前时间，不包含日期
SELECT CURTIME();

#str_to_date 将字符通过指定格式装换为日期
SELECT STR_TO_DATE('1998-3-21','%Y-%c-%d') AS out_put;

#查询入职日期为1992--4-3的员工信息
SELECT * FROM employees WHERE hiredate='1992-4-3';

SELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3-1992','%c-%d-%Y');

#data_formate 将日期转换成字符
SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;

#四、其他函数
SELECT VERSION();
SELECT DATABASE();
SELECT USER();

#五、流程控制函数
#1.if 函数：if else的效果
SELECT IF(10>5,'da','xiao');

SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻') AS out_put
FROM employees;

#2.case函数的使用一：switch case 的效果
/*
case 要判断的字段或表达式
when 常量一 then 语句1;
when 常量二 then 语句2;
...
else 要显示的值n或语句n;
end
*/

/*
查询员工的工资，要求
部门号=30，显示的工资为1.1倍
部门号=40，显示的工资为1.2倍
部门号=50，显示的工资为1.3倍
其他部门，显示原工资

*/

SELECT salary 原始工资, department_id,
CASE department_id
WHEN 30 THEN salary*1.1
WHEN 40 THEN salary*1.2
WHEN 50 THEN salary*1.3
ELSE salary
END AS 新工资
FROM employees;

#3.case函数的使用二：类似于多重if
/*
case
when 条件1 then 语句1
when 条件2 then 语句2
...
else 语句n
end
*/

SELECT salary,
CASE
WHEN salary>20000 THEN 'A'
WHEN salary>15000 THEN 'B'
WHEN salary>10000 THEN 'c'
ELSE 'D'
END AS 工资级别
FROM employees;

```

###### 分组函数

```sql
# 分组函数
/*
功能：用作统计使用，又称为聚合或统计函数
分类：
sum 求和、avg 平均值、max 最大值、min最小值、count计算个数
其中sum avg用于数值型
max min count支持所有类型

都会忽略null再运算
*/

# 1、简单使用
SELECT SUM(salary) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT MIN(salary) FROM employees;
SELECT MAX(salary) FROM employees;
SELECT COUNT(salary) FROM employees;

# 2、参数类型支持哪些类型
SELECT SUM(last_name),AVG(last_name) FROM employees;

SELECT MAX(last_name),MIN(last_name) FROM employees;

SELECT MAX(hiredate),MIN(hiredate) FROM employees;

# 3、 和distinct搭配
SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;
SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;

# 4、count函数的详细介绍
SELECT COUNT(salary) FROM employees;
SELECT COUNT(*) FROM employees;

SELECT COUNT(1) FROM employees;


# 5、和分组函数一同查询的字段有限制，要求是group by后的字段

SELECT DATEDIFF(NOW(),'1998-4-17');

```

###### 分组查询

```sql
# 进阶5：分组查询
/*
语法：	
	select 分组函数，列（要求出现在group by的后面）
	from 表
	【where 筛选条件】
	group by 分组的列表
	【order by 子句】
注意：查询列表必须特殊，要求是分组函数和group by 后出现的字段

特点：
	1、分组查询中的筛选条件分为两类
			数据源		位置			关键字
	分组前筛选	原始表		group by子句的前面	where
	分组后筛选	分组后的结果表	group by子句的后面	having
	
*/
#引入：查询每个部门的平均工资
SELECT AVG(salary) FROM employees;

#简单查询
#案例1：查询每个工种的最高工资
SELECT MAX(salary), job_id
FROM employees
GROUP BY job_id;

#案例2：查询每个位置上的部门个数
SELECT COUNT(*),location_id
FROM departments
GROUP BY location_id;

#添加筛选条件
#案例1：查询邮箱中包含a字符的，每个部门的平均工资

SELECT AVG(salary),department_id
FROM employees
WHERE email LIKE '%a%'
GROUP BY department_id;


```

##### JDBC连接数据库

```java
public void getConnection5() throws Exception{
        //1.读取配置文件中的4个基本信息
        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("jdbc.properties");
        Properties pros = new Properties();
        pros.load(is);
        String user=pros.getProperty("user");
        String password=pros.getProperty("password");
        String url=pros.getProperty("url");
        String driverClass=pros.getProperty("driverClass");
        //2.加载驱动
        Class.forName(driverClass);
        //3.获取连接
        Connection conn=DriverManager.getConnection(url,user,password);
        System.out.println(conn);
    }
```

## MySQL基础

参考文章：

[MySQL索引底层](https://mp.weixin.qq.com/s/ZZNnMU9SbBLNpLKUFWljcg)

##### MySQL索引主要使用的两者数据结构

- **哈希索引**，对于哈希索引来说，底层的数据结构肯定是哈希表，因此**在绝大多数需求为单条记录查询**的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引

- **BTree索引**，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。

  但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

##### 为什么使用索引？

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 帮助服务器避免排序和临时表
- 将随机IO变为顺序IO。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

##### MySQL中有四种索引类型，可以简单说说吗？

- **FULLTEXT** ：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。
- **HASH** ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
- **BTREE** ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
- **RTREE** ：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。

##### B树、B+树区别及应用？

B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树，高度比其他树小得多，磁盘I/O所花的时间就更少



**B树（多路查找树）**

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210424170755.png)

一个M阶B树的特征：M为层数

1.根节点的儿子范围[2,M]

2.每个非根节点包含k-1个关键字和k个孩子，k的范围[ceil(M/2),M]

3.叶子节点没有孩子

3.所有键值分布在整个树中

4.搜索可能在非叶子节点结束

5.假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]<Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。

6.所有叶子节点位于同一层。



设计思想：

将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据。



应用：

如mongoDB数据库使用，单次查询平均快于Mysql。



**B+树**

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210424171453.png)

B+树性质

- 有m个孩子的节点就有m个关键字(孩子数量=关键字数)，而在B树中孩子数量=关键字数+1
- 非叶子节点关键字也会出现在子节点中，而且子节点中为所有关键字的最大或最小
  非叶子节点只是用来索引，不保存数据的记录。在B树中，非叶子节点既保存索引也保存数据记录。
- 所有关键字都存在于叶子节点，叶子节点构成有序链表，而且关键字按照从大到小或者从小到大顺序连接。

优点：

- 因为B+树中间节点没有数据，所以同样大小的磁盘页可以容纳更多的节点元素，也就是说在相同的情况下，B+树更加的矮胖，这样的话，IO的次数也就比较少。
- B+树的查询相比B树更加稳定，因为B+树的查询是必须到叶子节点，而B树有可能在中间节点，也可能非中间节点。
- B+树叶子节点形成了有序链表，更加有利于范围的查询

> 那么其查询的过程是什么样的呢。我们假设查询元素13

- 首先与根节点的关键字(10,18,40)比较，13在10和18之间，此时得到P1指针
- 磁盘2中的关键字为(10,12,15),这时15大于13，所有磁盘6
- 关键字为(12,13)，找到13

应用：

mysql

##### 文件索引和数据库索引为什么使用B+树

文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。

最重要的是，B+树还有一个最大的好处：方便扫库。

B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。

B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。

B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；

B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

##### 数据库索引为什么用B+树而不是B树

主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

##### 创建表的时候为什么要用自增id作为主键？

```sql
CREATE TABLE mytable (
  # int 类型，不为空，自增
  id INT NOT NULL AUTO_INCREMENT,
  # int 类型，不可为空，默认值为 1，不为空
  col1 INT NOT NULL DEFAULT 1,
  # 变长字符串类型，最长为 45 个字符，可以为空
  col2 VARCHAR(45) NULL,
  # 日期类型，可为空
  col3 DATE NULL,
  # 设置主键为 id
  PRIMARY KEY (`id`));
```

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后序位置，当一页写满，就会自动开辟一个新的页。如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。

##### 存储引擎

MySQL 5.5 以前，默认引擎是MyISAM，之后默认引擎为InnoDB 

##### MyISAM和InnoDB的区别

**1.是否支持行级锁**

MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！

**2.是否支持事务**

MyISAM 不提供事务支持。

InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。

**3.是否支持外键**

MyISAM 不支持，而 InnoDB 支持。

🌈 拓展一下：

一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。

**4.是否支持数据库异常崩溃后的安全恢复**

MyISAM 不支持，而 InnoDB 支持。

使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。

🌈 拓展一下：

- MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。
- MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

**5.是否支持 MVCC**（多版本并发控制）

MyISAM 不支持，而 InnoDB 支持。

讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。

MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。

##### 表级锁与行级锁

- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

##### 事务

事务是逻辑上的一组操作，要么都执行，要么都不执行。

数据库事务：保证多个对数据库的操作（也就是SQL语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功，要么全部不执行**。

```sql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1  SQL2 
# 提交事务
COMMIT;
```

关系型数据库事务都由**`ACID`**特性

##### ACID

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durabilily`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

**数据事务的实现原理呢？**

我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

##### 并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复读和幻读区别：**

不可重复读的重点是**修改**比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于**新增或者删除**比如多次读取一条记录发现记录增多或减少了。

- 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。
- 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。

##### 事务的隔离级别

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

------

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          | √    |
| READ-COMMITTED   | ×    | √          | √    |
| REPEATABLE-READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |

##### MySQL 的默认隔离级别是什么?

MySQL InnoDB的 REPEATABLE-READ（可重复读），使用Next-Key Lock 锁算法可以避免幻读的产生，达到SERIALIZABLE（可串行化）隔离级别。

##### MySQL是如何执行一条SQL的？具体步骤有哪些？

Server层按顺序执行sql的步骤为：

1. 客户端请求->
2. 连接器（验证用户身份，给予权限） ->
3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）->
4. 分析器（对SQL进行词法分析和语法分析操作） ->
5. 优化器（主要对执行的sql优化选择最优的执行方案方法） ->
6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）->
7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

简单概括：

- **连接器**：管理连接、权限验证；
- **查询缓存**：命中缓存则直接返回结果；
- **分析器**：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）
- **优化器**：执行计划生成、选择索引；
- **执行器**：操作引擎、返回结果；
- **存储引擎**：存储数据、提供读写接口。

[一条SQL语句在MySQL中如何执行](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd)

##### MySQL的构造，分为哪两个部分？

可以分为服务层和存储引擎层两部分，其中：

**服务层包括连接器、查询缓存、分析器、优化器、执行器等**，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

**存储引擎层负责数据的存储和提取**。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。

##### Drop、Delete与Truncate的共同点和区别？

**第一种回答**

Drop、Delete、Truncate都表示删除，但是三者有一些差别：

**Delete**用来删除表的全部或者一部分数据行，执行Delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。

**Truncate**删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比Delete更快，占用的空间更小。

**Drop**命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。

因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。

**第二种回答**

- Drop直接删掉表;
- Truncate删除表中数据，再插入时自增长id又从1开始 ;
- Delete删除表中数据，可以加where字句。

##### MySQL性能优化

- 为搜索字段创建索引
- 避免使用 Select *，列出需要查询的字段
- 垂直分割分表
- 选择正确的存储引擎

[MySQL高性能优化](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd)

##### 大表优化

当MySQL单表记录数过大时，数据库的CRUD性能明显下降，一些优化措施如下：

- 限定数据的范围
- 读/写分离
- 垂直分区
- 水平分区

##### 数据库悲观锁与乐观锁的原理和应用场景

悲观锁，先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。

##### 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？

分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。

**通过分表**，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。分表策略可以归纳为垂直拆分和水平拆分:

**水平分表**：取模分表就属于随机分表，而时间维度分表则属于连续分表。如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。

**库内分表**，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。

**分库与分表带来的分布式困境与应对之策**数据迁移与扩容问题----一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。分页与排序问题----需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。

##### 解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?

常见的有Java线程池、jdbc连接池、redis连接池。这种设计会初始化预设资源，解决问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销。

数据库连接本质就是一个socket的连接。数据库服务端还要维护一些缓存和用户权限信息之类的，所以占用了一些内存。可以把数据库连接池看做是维护数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。

在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有的连接，则会建立一个新连接并将其添加到池中。连接池还减小了用户必须等待建立与数据库的连接的时间。





## 场景题

#### 假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？

- 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
- 选择合适的表字段数据类型和存储引擎，适当的添加索引。
- MySQL库主从读写分离。
- 找规律分表，减少单表中的数据量提高查询速度。
- 添加缓存机制，比如Memcached，Apc等。
- 不经常改动的页面，生成静态页面。
- 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。

#### 一条SQL语句执行得很慢的原因有哪些？

[一条SQL语句执行得很慢的原因有哪些？---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN%23rd)

#### 书写高质量SQL的建议

[书写SQL的建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN%23rd)

#### 执行数据库查询时，如果要查询的数据有很多，假设有1000万条，用什么方法可以提高查询效率（速度）？在数据库方面或Java代码方面有什么优化的办法？

1.在数据库设计方面

- （1） 建立索引
- （2） 分区（MySql，比如按时间分区）
- （3） 限制字段长度

2.在数据库I/O方面

- （1） 增加缓冲区
- （2） 如果设计标的级联，不同的表存储在不同的磁盘上，以增加I/O的读写效率

3.在SQL语句方面

- （1） 优化SQL语句，减少比较的次数
- （2） 限制返回的条目数（MySql中使用limit）

4.在Java方面

- 如果是反复使用的查询，使用PreparedStatement减少查询的次数。

## Redis





