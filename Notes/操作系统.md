









## 操作系统基础

##### 冯诺依曼架构

现代计算机之父冯诺伊曼最先提出程序存储的思想，并成功将其运用在计算机的设计之中，该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是**中央处理器（CPU）、内存、输入设备、输出设备、总线**。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/冯诺依曼架构.png" style="zoom:67%;" />

 

1.**存储器**：代码跟数据在RAM跟ROM中是线性存储，数据存储的单位是一个二进制位。最小存储单位是字节。

2.**总线**：总线是用于 CPU 和内存以及其他设备之间的通信，总线主要有三种：

- 地址总线：用于指定CPU将要操作的内存地址。
- 数据总线：用于读写内存的数据。
- 控制总线：用于发送和接收信号，比如中断、设备复位等信号，CPU收到信号后响应，这时也需要控制总线。

3.**输入/输出设备**：输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。比如键盘按键时需要和     CPU 进行交互，这时就需要用到控制总线。

4.**CPU**：中央处理器，类比人脑，作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU用寄存器存储计算时所需数据，寄存器一般有三种：

- 通用寄存器：用来存放需要进行运算的数据，比如需进行加法运算的两个数据。
- **程序计数器**：用来存储CPU要执行下一条指令所在的内存地址。

  当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。

- 指令寄存器：用来存放程序计数器指向的指令本身。

 

计算机系统自下而上可粗分为四个部分：硬件、操作系统、应用程序和用户。

 

##### 什么是操作系统？

1.操作系统（Operating System）是管理计算机硬件与软件资源的程序，是计算机的基石。

2.操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。

3.操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。

4.**操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。     内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。**

 

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/操作系统.png" style="zoom:50%;" />

综上所述，操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机工作和资源的分配，以提供给用户和其他软件方便的接口和环境集合。

#####  CPU vs Kernel（内核）

操作系统的内核属于操作系统层面，而CPU属于硬件。

CPU主要提供运算，处理指令的能力。内核主要负责系统管理如内存管理，它屏蔽了对硬件的操作。

##### 操作系统的基本特征

1.**并发**

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

2.**共享**

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时访问。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

3.**虚拟**

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

4.**异步**

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

##### 什么是系统调用？

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

1. 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。
2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

说了用户态和系统态之后，那么什么是系统调用呢？

我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

#####  内核态与用户态的区别？如何切换？

**内核态**

一个进程执行系统调用而陷入内核代码时，称为内核态。此时处理器处于最高级权限，可以使用内核栈

**用户态**

进程执行用户自己的代码时，处于用户态。此时权限最低

**用户态切换到进程态**

- 系统调用，其机制核心是操作系统为用户提供了一个特定的中断
- 异常，当出现某些事件不可知的异常时，会触发在内核中的异常梳理程序（异常称为同步中断，需要等待时钟同步）
- 外围设备的中断，完成IO操作以后，会向CPU发出中断信号，此时CPU会暂停当前的指令进入内核态去完成IO操作

##### 系统调用？

操作系统提供给用户的接口，可以用来请求操作系统的服务。常见的系统调用包括：文件相关操作、系统控制、进程控制。

在Linux中，每个系统调用分配了一个系统调用号。当用户空间的进程执行一个系统调用的时候，这个系统调用号用来指明需要执行那个系统调用，而不再提及名称。



**使用系统调用与使用普通函数的区别？**

普通函数可以再不同系统上实现，但系统调用在不同系统上差别却可能很大。



##### 内核同步？

**临界区：**访问和操作共享数据的**代码段**

**竞争条件：**如果两个执行线程有可能处于同一个临界区中同时执行

**同步：**避免并发和防止竞争条件称为同步



**原因：**

内核中也有可能造成并发执行：  中断、软中断和tasklet、内核抢占、睡眠、对称多处理



**方法：**

1.原子操作

将行为包含在一个单步中执行，以保证执行过程不会被打断。

2.自旋锁

如果一个执行线程视图获得一个已经被持有的锁，那么该线程会一直进行循环等待直到重新可用

3.读写锁

明确区分读取和写入场景的自旋锁

4.信号量

如果一个任务视图获得一个不可用的信号量，信号量会将其推进一个等待队列，使其睡眠。这时处理器去执行别的事情。当信号量可用时再被唤醒。

5.互斥锁

相较于自旋锁，它可以睡眠，处理器效率更高，但开销比较大。

6.完成变量

一个任务发出信号通知另一个任务发生了某个特定事件

7.大内核锁

全局自旋锁，为了方便linux从最初的SMP过渡到细粒度加锁机制



##### 引导过程？

1. BIOS

   固化在板子上，开机先读取BIOS程序。硬件自检，看是否满足运行条件。之后到MBR（可启动存储设备的第一个扇区）内拿到bootloader 的位置。

2. bootloader

   bootloader内有操作系统的相关信息，如名称、内核位置等，它的功能是将操作系统加载到内存内。Linux常用的bootloader是GRUB。

3. kernel

   再次检查硬件、加载驱动程序

4. init程序

   运行的第一个程序，用于初始化系统环境，启动其他进程

 

## 进程管理

##### 进程与线程的区别

进程

进程就是应用程序在内存中分配的空间，也就是正在运行的程序。进程是资源分配的基本单位

线程

线程是独立调度的基本单位

 

  一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。

  总结： 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。 

**区别：**

①拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

②调度：线程是独立调度的基本单位，在同一个进程中，线程的切换不会引起进程的切换，从一个线程切换到另一个进程中的线程时，会引起进程切换。

③系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

④通信方面：线程间可以通过读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

##### 进程拥有多少资源？

除了运行时那些段，还有以下这些：

**会被子进程继承的：**

用户号UID，组号GID，进程组号，虚拟地址空间，堆栈，共享内存，打开的文件描述符，工作目录，根目录，资源控制，环境终端

**不会被继承的独有的：**

进程号PID，父进程号，自己的文件描述符和目录流的拷贝，进程正文，数据，和其他锁定内存，不继承异步输入输出



在linux中使用mm_struct结构体表示内存描述符，内包含了和进程地址空间有关的全部信息。所有的mm_struct结构体通过自身的mmlist连接在一个双向链表中。该链表的首元素是init_mm内存描述符，它代表init进程的地址空间。

##### 并行和并发？

并行：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果。

看CPU**有没有一个以上的核**，否则无法并行。

##### 进程的状态

- **创建状态**(new) ：进程正在被创建，尚未到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的进程控制块（PCB），并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。
- **就绪状态**(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态**(running) ：进程正在处理器上上运行(单核     CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态**(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待     IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态**(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618909775561.png" style="zoom:67%;" />

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得     CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括  CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

##### 进程调度算法

1、**批处理系统**

- 先来先服务(FCFS)调度算法 （非抢占式）:     从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- 短作业优先(SJF)的调度算法（非抢占式） :     从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- 最短剩余时间优先（SRTN）：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。     当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

2、**交互式系统**

- 时间片轮转调度算法 :     时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round     robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX     操作系统采取的便是这种调度算法。
- 优先级调度 ：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS     方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

##### 进程间的通信方式

1. **管道/匿名管道**(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道**(Names Pipes) :     匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号**(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. 消息队列(Message     Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比     FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
5. **信号量**(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存**(Shared     memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字**(Sockets) :     此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP     的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

##### 线程间的通信方式

- 使用全局变量
            主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile 
- 使用消息实现通信
                在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。

1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20; 
 2)添加消息函数声明afx_msg int OnTSendmsg(); 
 3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM) 
 4)添加OnTSM()的实现函数；
 5)在线程函数中添加PostMessage消息Post函数

- 使用事件CEvent类实现线程间通信
            Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。

1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态； 
 2)threadStart.SetEvent();使其处于通信状态； 
 3)调用WaitForSingleObject()来监视CEvent对象

##### 线程间的同步方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

**互斥量**(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

**信号量**(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

**事件**(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

##### 协程？

进程、线程由内核调度。协程是用户态下的线程，自行调度，不用陷入内核。

优势：

- 跨平台
- 跨体系架构
- **无需上下文切换**
- **无需同步的开销**

所以效率更高



##### 僵尸进程、孤儿进程、守护进程？

**僵尸进程：**使用fork创建子进程，子进程退出之后，父进程没有调用wait或waitpid获取子进程状态信息。此时**子进程的程序描述符仍然保存在系统中**，因此成为僵尸进程

**孤儿进程：**父进程退出了，而它的子进程仍在运行，这些子进程成为孤儿进程。这些孤儿进程将被init进程收养，并由init进程完成他们的状态收集工作

**守护进程：**是在后台运行不受终端控制的进程（如输入、输出等）



##### 进程结束时的内存释放？

进程结束后，进程的所有的虚拟地址空间就会被**直接销毁，包括堆上的内存泄露的内存**。

方式：让内存管理模块把分页文件中与此进程相关的记录全部删除，**标记为“可用空间”**。

但是，有些内存系统是回收不了的。例如运行于内核级的驱动造成的内存错误等， 这些是系统所管不了的。

## 内存管理

操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

##### 常见的几种内存管理机制

简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理 和 段式管理。

1. 块式管理 ：远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. 页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. 段式管理 ：     页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多     。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。     段式管理通过段表对应逻辑地址和物理地址。
4. 段页式管理：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。

##### 快表与多级页表

在分页内存管理中，很重要的两点是：

1. 虚拟地址到物理地址的转换要快。
2. 解决虚拟地址空间大，页表也会很大的问题。

快表

为了解决虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

 

看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。

多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章：[多级页表如何节约内存](https://www.polarxiong.com/archives/多级页表如何节约内存.html)

##### 分页机制与分段机制的共同点与区别

1. 共同点 ：

2. - 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
   - 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

3. 区别 ：

4. - 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
   - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。
   - 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

##### 逻辑（虚拟）地址和物理地址

 编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。

##### CPU寻址，为什么需要虚拟地址空间？

现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。如下图所示：

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618910313550.png" style="zoom: 50%;" />

 

没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存 。但是这样有什么问题呢？

1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。
2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个     QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ     音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。

总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。

通过虚拟地址访问内存有以下优势：

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为     4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

##### 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

1、最佳

  所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

2、最久未被使用

  虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

  为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

3、最近未使用

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

4、先进先出

先择换出的页面式最先进入的页面。该算法会将那些经常被访问的页面换出，导致缺页率升高。

5、第二次机会算法

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

6、时钟

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。



> 地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。
>
> 缺页中断 就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。
>
> 当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。
>
> - OPT     页面置换算法（最佳页面置换算法） ：最佳(Optimal,     OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
> - FIFO（First     In First Out） 页面置换算法（先进先出页面置换算法） :     总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
> - LRU     （Least Currently     Used）页面置换算法（最近最久未使用页面置换算法） ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间     T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
> - LFU     （Least Frequently Used）页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页

#####  虚拟内存

虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。

##### 局部性原理

早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。

局部性原理表现在以下两个方面：

1. 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
2. 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。

##### 虚拟内存的技术实现

虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：

1. 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
2. 请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. 请求段页式存储管理

 

这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？

请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。

它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。

不管是上面那种实现方式，我们一般都需要：

1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
2. 缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；
3. 虚拟地址空间 ：逻辑地址到物理地址的变换。

## 设备管理

##### 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track     Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator     arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/磁盘.jpg" style="zoom:50%;" />

 

##### 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

1、先来先服务

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

2、最短寻道时间优先

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

3、电梯算法

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

##  I/O

### 网络编程

#### 五大IO模型？

![](https://gitee.com/sun-qiao321/picture/raw/master/images/IO模型.png)

**同步模型/异步模型？**

同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。相对于同步IO，异步IO不是顺序执行，等待数据和拷贝数据到用户空间这两个阶段都不阻塞。



**同步模型：**

- **阻塞IO**：用户空间的程序执行系统调用，需要等待这个系统调用将数据从内核复制到用户空间，期间不使用CPU只是单纯的等待响应。（及时获取数据，但消耗系统性能）
- **非阻塞IO**：即轮询模式，反复调用以不断检查内核数据直到准备完成。（提升了性能，但任务完成的响应延迟增大，使得数据整体吞吐量降低）
- **IO多路复用**：系统帮你做轮询，看到能使用的就通知你。（能够同时处理多个IO读写，但顺序不固定）
- **信号驱动IO**：进程建立信号和信号处理函数，此时进程继续运行并不阻塞。数据处理完成以后内核给进程发送信号，在信号处理函数中处理数据

**异步模型：**

- **异步IO**： 用户进程发起操作后，可以直接去做其他事情。内核完成数据准备+数据拷贝之后会发送一个信号，或者一个回调函数完成用户态处理。



#### IO复用机制？

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/IO复用机制.png" style="zoom:67%;" />

**select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。select底层是数组，所以存在最大链接数，而poll是链表，不存在最大链接数**

**但是epoll不存在这个问题，它只会对"活跃"的socket进 行操作**---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。于是，只有"活跃"的socket才会主动去调用 callback函数。



#### 水平触发/边沿触发？（epoll的两种工作方式？）

**水平触发：**只要有数据都会触发。但是只要还有数据，内核就会不停的从内核空间转到用户空间，占用了大量的资源。
**边沿触发：**只有数据到来时才触发，过后不会进行更多的通知。所以你如果一直不对这个fd做IO操作导致变成了未就绪，一样不会进行通知，因此无法保证数据完整性。



#### epoll工作原理？

0. epoll在内核初始化的时候向内核注册了一个文件系统，用于存储上述被监控的socket，同时还会开辟出epoll自己的内核高速cache区，用于安置需要监控的fd。

   

1. 使用epoll_create。调用epoll_create时，会在这个虚拟的epoll文件系统里创建一个file节点，在内核cache中建立个红黑树来存储通过epoll_ctl添加进来的fd。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层（物理上分配好你想要的大小的内存对象，创建好数据结构，每次使用时拿一个往里填充）。同时还会建立一个list链表，**用来存储已经就绪的事件**。

   

2. 使用epoll_ctl添加需要监听的文件，当我们执行epoll_ctl时，会把对应fd放到红黑树中，还会给内核终端处理程序注册一个回调函数。如果这个句柄的中断到了，就把它放在list链表中去。

```C++
long epoll_ctl(int epfd, int op, int fd,struct epoll_event *event);
```

- epfd 是通过epollcreat返回的文件句柄

- op是要进行的操作（添加 删除 修改）

- fd是要监听的文件句柄，他会被添加到epoll对象的等待队列（红黑树）中

- event是要**监听的事件（可读、可写。发生错误等）**

  

3. 调用epoll_wait等待被监听的文件状态发生变化，该函数会阻塞当前进程，改变时该函数会返回。epoll_wait调用时，就去看这个list链表是不是为空，若不为空就返回，为空就等待指定的事件再返回。这些fd其实已经在内核态了，当你再次调用epoll_wait时，不需要再拷贝进内核态（select需要再全部拷贝到内核态）。

```C++
long epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

- epfd是epoll句柄
- events**存放就绪文件列表**
- maxevents存放event数组大小
- timeout设置等待超时的时间
- 返回活跃数量



​	4.唤醒调用 `epoll_wait()` 函数被阻塞（睡眠）的进程。



　　总结一下：**一棵红黑树和一个list链表就解决大并发的问题**。epoll_create时创建红黑树和就绪链表，epoll_ctl时添加到红黑树中（若存在则不添加）并向内核注册回调函数。epoll_wait时返回list就绪链表里面的数据就可以了。



#### 两种高性能IO设计模式？

传统做法的问题：使用多线程模型，此时每个连接需要新建一个线程，消耗巨大；使用线程池模型，队列内有空闲的线程资源，需要拿走，用完归还。但是如果都是长连接的话，没有空余线程会导致客户连接失败

因此提出了两种高性能IO设计模式：

**reactor：**

主线程只负责监听文件描述符是否有事件发生，有的话会将事件分配到到其他对应的线程或者回调进行处理。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/reactor.jpg)

**proactor：**

将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑

![](https://gitee.com/sun-qiao321/picture/raw/master/images/proactor.jpg)



#### linux底层建立网络连接的流程？



<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/发起连接流程.png" style="zoom:67%;" />



1. 使用socket建立套接字描述符，选择类型和协议

2. 构建sockaddr结构体，里边包含地址信息

3. 使用bind函数关联结构体和套接字

4. （如果是处理面向连接的服务的客户端）使用connect建立连接

   4.1 如果是服务端，先调用listen（）进行监听，客户端使用connect后调用accept接受

5. 数据传输，讲道理read write读写文件就可以通信，但是还是设计了三组收发函数用于指定更多选项（ send/recv    sendto/recvto   sendmsg/recvmsg）

6. 关闭连接 shutdown，可以更方便的关闭套接字双向传输中的某个方向 （close需要等待所有引用都释放了才会释放这个套接字）



### 文件系统

#### 文件系统是如何组织的？

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/文件系统组织.png" style="zoom:67%;" />

文件系统，负责把用户的文件存到磁盘硬件中，不同的管理方式对应不同的文件系统。

Linux文件系统为每个文件分配两个数据结构：

**索引节点 index node：**记录文件元信息，如**inode编号**，文件大小，访问权限，修改时间，**磁盘位置**。是文件的唯一标识，存储在磁盘中同样占用磁盘空间。

**目录项 directory entry：** 记录文件名字，索引节点指针、与其他目录项的层级关系。多个目录项关联起来，就是目录结构，缓存在内存中。虽然他们可以统一由索引节点表示，但是VFS经常需要执行目录相关的操作，比如查找路径，为了方便以上操作而引入了目录项这一数据结构。



【目录和目录项的区别？】

目录项是数据结构，而**目录是文件**。普通文件在磁盘内存放文件数据，而目录文件在磁盘内保存子目录或文件。频繁从磁盘读目录效率低，所以**把读过的目录用目录项缓存在内存中**。



【目录项缓存机制？】

如果VFS层遍历路径名中的所有元素，并将他们诸葛解析成目录项对象，还要达到最深层目录，这将是一键非常费力的事情。所以内核将目录项对象缓存在目录项缓存【dcache】中。



#### 硬链接与软连接的区别

**硬链接**：多个文件名指向一个文件。这意味着，不同文件名可以访问相同的内容；为文件的修改会影响到所有文件名

**软链接：**文件A和文件B的inode号码虽然不一样，但是读取文件A时，系统会自动将访问者导向文件B。

**区别：**硬链接指向索引节点index node，软链接指向文件名（目录项directory entry）。因此软链接不会使inode中的链接数改变



#### 虚拟文件系统？

虚拟文件系统为用户空间程序提供了文件和文件系统相关的接口。 通过虚拟文件系统，程序可以利用标准的UNIX系统调用不同的文件系统，甚至不同介质上的文件系统。

内核在它的底层文件系统接口上建立了一个抽象层，它定义了所有文件系统都支持的接口和数据结构。



VFS中有四个主要的对象：

**超级块对象**，它代表一个具体的已安装的系统文件，存储特定文件系统的信息、操作方法。在文件系统安装时，文件系统会调用alloc_super函数以便从磁盘读取文件系统超级块，并将其信息填充到内存中的超级块对象中。

**索引节点对象**，它代表一个具体文件。被访问时才在内存中创建。

**目录项对象**，它代表一个目录项，是路径的一个组成部分

**文件对象**，是已经打开的文件在内存中的表示。



### 设备驱动

**块设备：**能够随机（不按照顺序）访问固定大小数据片的设备称为块设备。文件系统最小可寻址单元称为块。设备的最小可寻址单元称为扇区。

**字符设备：**按照字节流有序访问。与块设备区别在于能否随机访问（从一个位置跳到另一个位置）

**网络设备：**提供了对网络的访问。打破了Unix万物皆文件的设计原则，不再通过节点文件访问，而是通过套接字API。



#### 块设备

当一个块被调入内存时，它要存储在内存缓冲区中。每个缓冲区拥有一个描述符，用bio结构体管理。每个片段以链表形式组织在一起，就不再需要保证单个缓冲区一定要连续。

**IO调度程序**

为了优化块设备的IO寻址操作，内核在提交操作前会先执行合作与排序预操作以提高性能。 

linus电梯调度、最终期限IO调度、预测IO调度、完全公正的排队IO调度（默认）、空操作的IO调度

完全公正的排队IO调度：以进程区分队列，不同进程产生的IO请求放入特定的队列。刚进入的IO请求与相邻请求合并，并进行插入分类。每个队列由此按扇区方式分类，并以时间片轮转调度队列。



#### 字符设备

## Linux

虚拟机密码：Sun1998321

#### 常用的基本命令

##### 目录管理

cd : 切换目录命令

./ : 当前目录

cd.. ：返回上一级目录

*ls ：列出目录*

-a参数 ： all，查看全部的文件，包括隐藏文件

-l参数：列出所有的文件信息，包含文件的属性和权限，没有隐藏文件

pwd：显示当前所在的目录

mkdir：创建一个文件夹

mkdir -p ：创建层级目录

rmdir：删除文件夹（仅能删除空的）

rmdir -p：删除层级目录（删除不为空的多个）

cp：复制文件或目录（cp 原来地方 新的地方）

rm：移除文件或者目录

-f 忽略不存在的文件

-r 递归删除目录

-i 删除时询问是否删除

rm -rf/   移除系统中的所有文件，删库跑路

mv：移动文件或者目录   重命名文件

-f 强制移动

-u 只替换已经更新过的文件

##### 文件内容查看

cat 由第一行开始显示文件内容

tac 从最后一行开始显示

nl 显示的时候，顺道输出行号

more 一页一页的显示文件内容

less 与 more 类似，但是比more更好的是可以往前翻页

head 只看头几行

tail 只看尾巴几行



## Linux内核

### 组成

由内核、shell、系统调用和共用库函数、应用程序 4个部分组成。

**内核：** 由进程管理系统、内存管理系统、IO管理系统和文件管理系统四个子系统构成

**shell：**提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/内核组成.png" style="zoom:67%;" />





### 时钟管理

#### 各种概念

**墙上时间：**实际时间（如日期等） 

**系统运行时间：** 自系统启动开始所经过的时间

**实时时钟：**RTC是用持久存放系统时间的设备，即使系统关闭以后，也可以依靠电池供电。开机后内核会读取RTC时间，并存放在xtime变量中，用于初始化墙上时间。

**HZ：** 预处理时定义，时钟中断每秒触发HZ次  

**jiffies：** 记录当前已经触发过几次中断

**系统定时器：**提供周期性的触发中断机制