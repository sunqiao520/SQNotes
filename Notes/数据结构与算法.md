## 九大数据结构

参考来源：[24张图，九大数据结构（CodeSheep）](https://mp.weixin.qq.com/s/ZVwIUN-xf9FuxOFXW8H3Nw)

​                   [跳表（CodeSheep）](https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA)

### 数组

#### 二分法

一般题：在排好序无重复的数组中查找元素

```text
Input : [1,2,3,4,5]
key : 3
return the index : 2
```

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

有重复元素如何二分法？

```java
public static int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length;
    while (l < h) {
        int m = l + (h - l) / 2;
        if(nums[m] >= key) {
            h = m;
        }else {
            l = m + 1;
        }
    }
    return l;
}
```



###### 88、合并两个有序数组

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421091423237.png)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m-1 , index2 = n-1;    //为什么从后往前遍历
        int indexMerge = m+n-1;
        while(index1>=0 || index2>=0){
            if(index1 <0) nums1[indexMerge--] = nums2[index2--];
            else if(index2<0) nums1[indexMerge--] = nums1[index1--];
            else if(nums2[index2] <nums1[index1]) nums1[indexMerge--] = nums1[index1--];
            else nums1[indexMerge--] = nums2[index2--];
        }
    }
}
```



### 链表

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/数组与链表.png" style="zoom:50%;" />

###### 206、反转链表

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode newHead=null;
        while(head!=null){
           ListNode temp=head.next;
           head.next=newHead;
           newHead=head;
           head=temp;
        }
        return newHead;
    }
}
```



###### 141、判断链表是否成环

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421092340854.png)

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}
class Solution{
    public boolean hasCycle(ListNode head){
        if(head == null) return false;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) return true;
        }
        return false;
    }
}
```

###### 142、返回环的入口

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null && fast.next !=null){
            slow=slow.next;
            fast=fast.next.next;
            if(slow == fast){
                ListNode index1=head;
                ListNode index2=fast;
                while(index1 != index2){
                    index1=index1.next;
                    index2=index2.next;
                }
                return index2;
            }
        }  
        return null;
    }
}
```

###### 160、相交链表

找到两个链表相交的起始节点。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        while(pA != pB) {
            if(pA != null){
                pA = pA.next;
            }else {
                pA = headB;
            }
            if(pB != null){
                pB = pB.next;
            }else {
                pB = headA;
            }
        }
        return pA;
    }
}
```



### [跳表](https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA)

链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618916794542.png" style="zoom:50%;" />

跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。

从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。

###  栈与队列

###### 232、用栈实现队列

使用两个栈inStack() 和 outStack() 。入栈元素进inStack()，出栈时如果outStack() 有元素，则弹出；没有，则将inStack()弹到outStack()。

```java
class MyQueue {
    Deque<Integer> inStack;
    Deque<Integer> outStack;
    /** Initialize your data structure here. */
    public MyQueue() {
        inStack = new LinkedList<>();
        outStack = new LinkedList<>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        inStack.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(outStack.isEmpty()){
            intoout();
        }
        return outStack.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if(outStack.isEmpty()){
            intoout();
        }
        return outStack.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return outStack.isEmpty() && inStack.isEmpty();
    }
    public void intoout(){
        while(! inStack.isEmpty()){
            outStack.push(inStack.pop());
        }
    }
}
```



###### 225、用队列实现栈

```java
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;
    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue2.offer(x);
        while(!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue1.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return queue1.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

###### 347、前K个高频元素



### 树

**二叉排序树（二叉查找树、二叉搜索数）**：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。（中序遍历结果是有序的）

**平衡二叉树**：平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

 

为什么有了二叉排序数还要设计平衡二叉数？

由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的支树上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。

  因此构造平衡二叉树时需要在插入数据后保持平衡，有四种调整方式LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）

**红黑树**：

平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。

为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。

特性：

- 每个结点要么是红的要么是黑的。
- 根结点是黑的。
- 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
- 如果一个结点是红的，那么它的两个儿子都是黑的。
- 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618916838106.png" style="zoom:50%;" />

 

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/红黑树VS平衡二叉树.png" style="zoom:67%;" />

###### 递归三要素

- 确定递归函数的参数和返回值
- 确定终止条件
- 确定单层递归逻辑

###### 二叉树的定义

```java
public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val) { this.val = val;}
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

###### 前序遍历

**递归法：**

```java
class Solution{
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root,res);
        return res;
    }
    public void preorder(TreeNode root,List<Integer> res){
        if(root == null) return;
        res.add(root.val);
        preorder(root.left,res);
        preorder(root.right,res);
    }
}
```

**迭代法：**

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
      List<Integer> res = new ArrayList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node != null) res.add(node.val);
            else continue;
            stack.push(node.right);                           // 右
            stack.push(node.left);                            // 左
        }
        return res;
    } 
}
```



###### 中序遍历

**递归法：**

```java
class Solution{
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root,res);
        return res;
    }
    public void preorder(TreeNode root,List<Integer> res){
        if(root == null) return;
        preorder(root.left,res);
        res.add(root.val);
        preorder(root.right,res);
    }
}
```

**迭代法：**

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(!stack.isEmpty() || cur != null) {
            while (cur != null) {
                stack.push(cur);
                cur=cur.left;
            }
            TreeNode node = stack.pop();
            res.add(node.val);
            if(node.right != null) {
                cur = node.right;
            }
        }
        return res;
    }
}
```



###### 后序遍历

**递归法：**

```java
class Solution{
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root,res);
        return res;
    }
    public void preorder(TreeNode root,List<Integer> res){
        if(root == null) return;
        preorder(root.left,res);
        res.add(root.val);
        preorder(root.right,res);
    }
}
```

**迭代法：**

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
List<Integer> res = new ArrayList<Integer>();
if(root == null) {
    return res;
}
      Stack<TreeNode> stack1 = new Stack<TreeNode>();
      Stack<TreeNode> stack2 = new Stack<TreeNode>();
      stack1.push(root);
      while (!stack1.isEmpty()) {
          TreeNode node = stack1.pop();
          stack2.push(node);
          if (node.left != null) {
			  stack1.push(node.left);
		  }
		  if (node.right != null) {
			  stack1.push(node.right);
		  }
      }
      while (!stack2.isEmpty()) {
          res.add(stack2.pop().val);
      }
      return res;
    }
}
```

###### 层序遍历

```java
class Solution {
    public List<List<Integer>> leverOrder(TreeNode root){
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        if(root == null) return ret;
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>();
            int currentLevelSize = queue.size();
            for(int i = 0;i<currentLeverSize;i++){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
            }
            ret.add(level);
        }
        return ret;
    }
}
```



#### 常考路径问题

###### 257、二叉树的所有路径

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210430111634.png" style="zoom: 67%;" />

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<>();
        constructPath(root,"",paths);
        return paths;
    }
    private void constructPath(TreeNode root,String path,List<String> paths){
        if(root !=null){
            StringBuilder pathSB = new StringBuilder(path);
            pathSB.append(Integer.toString(root.val));
            if(root.left==null && root.right==null){
                paths.add(pathSB.toString());
            }else{
                pathSB.append("->");
                constructPath(root.left,pathSB.toString(),paths);
                constructPath(root.right,pathSB.toString(),paths);
            }
        }
    }
}
```

###### 112、路径总和

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210430111810.png)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
       if(root == null) return false;
       return traver(root,targetSum-root.val);
    }
    public boolean traver(TreeNode root,int targetSum){
        if(root.left == null && root.right == null && targetSum == 0) return true;
        if(root.left == null && root.right == null ) return false;
        if(root.left != null) {
            if(traver(root.left,targetSum-root.left.val)) return true;
        }
        if(root.right !=null){
            if(traver(root.right,targetSum-root.right.val)) return true;
        }
        return false;
    }
}
```



###### 二叉树的最大路径和

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210430110047.png" style="zoom: 67%;" />

```java
import java.util.*;
 
/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */
 
public class Solution {
    /**
     *
     * @param root TreeNode类
     * @return int整型
     */
    int maxsum = Integer.MIN_VALUE;
    public int maxPathSum (TreeNode root) {
        // write code here
        if(root == null) return 0;
        maxSum(root);
        return maxsum;
    }
    public int maxSum(TreeNode root){
        if(root == null) return 0;
        int left = maxSum(root.left);
        int right = maxSum(root.right);
        int sum = root.val;
        if(left >0){
            sum += left;
        }
        if(right >0){
            sum += right;
        }
        if(maxsum < sum){
            maxsum = sum;
        }
        return Math.max(left,right)>0? Math.max(left,right)+root.val :root.val;
    }
}
```

###### 统计二叉树的最优质路径

```java
package Test;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.*;
public class test7 {
    //通过数组创建二叉树
    private static TreeNode creatBinaryTreeByArray(int[] array,int index){
        TreeNode tn = null;
        if(index<array.length){
            int value = array[index];
            tn = new TreeNode(value);
            tn.left=creatBinaryTreeByArray(array, 2*index+1);
            tn.right=creatBinaryTreeByArray(array, 2*index+2);
            return tn;
        }
        return tn;
    }
    //找到路径
    static LinkedList<List<Integer>> res = new LinkedList<>();
    static LinkedList<Integer> path = new LinkedList<>();
    static int count = 0;
    private List<List<Integer>> pathSum(TreeNode root,int sum){
        recur(root,sum);
        return res;
    }
    void recur(TreeNode root,int target){
        if(root == null) return;
        path.add(root.val);
        target-=root.val;
        if(target==0 )
             res.add(new LinkedList<>(path));
        recur(root.left, target);
        recur(root.right, target);
        path.removeLast();
    }
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        String a = scanner.nextLine();
        String[] strArr = a.substring(1,a.length()-1).split(","); 
        int[] value = new int[strArr.length];
        for(int i = 0;i<strArr.length;i++){
            value[i] = Integer.valueOf(strArr[i]);
        }
        int target = scanner.nextInt();
        TreeNode root = creatBinaryTreeByArray(value,0);
        new test7().pathSum(root, target);
        int length = Integer.MAX_VALUE;
        for(int i = 0;i<res.size();i++){
            if(res.get(i).size()<length){
                length=res.get(i).size();
                count = i;
            }
        }
        System.out.println(res.get(count));
    }
}

//节点的定义
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

#### 公共祖先问题

###### 236、二叉树的最近公共祖先

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left == null && right == null) return null;
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```



###### 235、二叉搜索树的最近公共祖先

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val>p.val && root.val>q.val) return lowestCommonAncestor(root.left,p,q);
        else if(root.val<p.val && root.val<q.val) return lowestCommonAncestor(root.right,p,q);
        else return root;
    }
}
```



#### 二叉树的构造

###### 将数组转化为二叉树

```java
//通过数组创建二叉树
private static TreeNode creatBinaryTreeByArray(int[] array,int index){
    TreeNode tn = null;
    if(index<array.length){
        int value = array[index];
        tn = new TreeNode(value);
        tn.left=creatBinaryTreeByArray(array, 2*index+1);
        tn.right=creatBinaryTreeByArray(array, 2*index+2);
        return tn;
    }
    return tn;
}
```



###### 将有序数组转化为二叉搜索树（108）

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return dfs(nums, 0, nums.length - 1);
}

private TreeNode dfs(int[] nums, int lo, int hi) {
    if (lo > hi) {
            return null;
    } 
     // 以升序数组的中间元素作为根节点 root。
    int mid = lo + (hi - lo) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    // 递归的构建 root 的左子树与右子树。
    root.left = dfs(nums, lo, mid - 1);
    root.right = dfs(nums, mid + 1, hi); 
    return root;
}

```



###### 105、从前序与中序遍历序列构造二叉树

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210430111318.png" style="zoom:50%;" />

```java
class Solution {
    HashMap<Integer,Integer> map = new HashMap<>();
    int[] pre;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i = 0;i<inorder.length;i++) map.put(inorder[i],i);
        pre = preorder;
        TreeNode root = buildTree(0,preorder.length-1,0,inorder.length-1);
        return root;
    }
    private TreeNode buildTree(int ps,int pe,int is, int ie){
        if(pe<ps || ie<is) return null;
        int rootValue = pre[ps];
        int ri = map.get(rootValue);
        TreeNode root = new TreeNode(rootValue);
        root.left = buildTree(ps+1, ps+ri-is ,is,ri-1);
        root.right = buildTree(ps+ri-is+1,pe,ri+1,ie);
        return root;
    }
}
```

###### 106、从中序和后序遍历序列构造二叉树

```java
class Solution {
    HashMap<Integer,Integer> memo = new HashMap<>();
    int[] post;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for(int i = 0;i < inorder.length; i++) memo.put(inorder[i], i);
        post = postorder;
        TreeNode root = buildTree(0, inorder.length - 1, 0, post.length - 1);
        return root;
    }

    public TreeNode buildTree(int is, int ie, int ps, int pe) {
        if(ie < is || pe < ps) return null;

        int root = post[pe];
        int ri = memo.get(root);

        TreeNode node = new TreeNode(root);
        node.left = buildTree(is, ri - 1, ps, ps + ri - is - 1);
        node.right = buildTree(ri + 1, ie, ps + ri - is, pe - 1);
        return node;
    }
}
```



###  堆

 堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。

 

  对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。

 

  不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618916878756.png" style="zoom:67%;" />

######  Kth Element / TopK Elements

- 第K大的元素   / K个最小的元素（从小到大第K个）

方法一：使用最小的元素来建立大顶堆（堆顶元素为当前堆的最大元素）。不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为log<sub>2</sub>N。

方法二：快速选择的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。，找到Kth Element之后，再遍历一次数组，所有小于等于Kth Element的元素都是TopK Elements。

- 第K个最大的元素 / K 个最大的元素（从大到小第K个）

方法一：使用最大的元素来建立小顶堆（堆顶元素为当前堆的最小值）。实现过程：不断的往小顶堆中插入新元素，当堆中元素的数量大于K时，则移除堆顶元素。最后堆中元素为最大的K个。

Java中的优先队列PriorityQueue实现了小堆顶。add() poll() peek()

方法二：快速选择

215、数组中的第K个最大元素

排序：时间复杂度O(NlogN)，空间复杂度 O(1)

```java
public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
}
```

堆：时间复杂度O（NlogK），空间复杂度O（K）

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();  //小顶堆
        for(int val : nums){
            pq.add(val);
            if(pq.size()>k) pq.poll();    //pq中始终为插入的最大的K个
        }
        return pq.peek();
    }
}
```

快速选择：时间复杂度 O(N)，空间复杂度 O(1)

```java
public int findKthLargest(int[] nums, int k) {
    k = nums.length - k;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int j = partition(nums, l, h);
        if (j == k) {
            break;
        } else if (j < k) {
            l = j + 1;
        } else {
            h = j - 1;
        }
    }
    return nums[k];
}

private int partition(int[] a, int l, int h) {
    int i = l, j = h + 1;
    while (true) {
        while (a[++i] < a[l] && i < h) ;
        while (a[--j] > a[l] && j > l) ;
        if (i >= j) {
            break;
        }
        swap(a, i, j);
    }
    swap(a, l, j);
    return j;
}

private void swap(int[] a, int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```



### 散列表

###### 面试题 16.24. 数对和

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210430151552.png)

```java
class Solution {
    public List<List<Integer>> pairSums(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Map<Integer,Integer> map = new HashMap<>();
        for(int num:nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        for(int num1 : map.keySet()){
            int num2 = target - num1;
            if(map.containsKey(num2) && map.get(num2) >0){
                int count = 0;
                if(num1 == num2){
                    count = map.get(num1)/2;
                }else{
                    count = Math.min(map.get(num1),map.get(num2));
                }
                for(int i = 0;i<count;i++){
                    res.add(Arrays.asList(num1,num2));
                }
                map.put(num1,0);
                map.put(num2,0);
            }
        }
        return res;
    }
}
```



###### 15、三数之和

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210430091200.png)

首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L]和 nums[R]，计算三个数的和 sum判断是否满足为 0，满足则添加进结果集

如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环

如果 nums[i] = nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过

当 sum = 0 时，nums[L] = nums[L+1] 则会导致结果重复，应该跳过，L++

当 sum= 0 时，nums[R] =nums[R−1] 则会导致结果重复，应该跳过，R−−

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        if (nums == null || len < 3)
            return ans;
        for (int i = 0; i < len; i++) {
            if (nums[i] > 0)
                break;
            if (i > 0 && nums[i] - nums[i - 1] == 0)
                continue;
            int L = i + 1;
            int R = len - 1;
            while (L < R) {
                int sum = nums[i] + nums[L] + nums[R];
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L] == nums[L + 1])
                        L++;
                    while (L < R && nums[R] == nums[R - 1])
                        R--;
                    L++;
                    R--;
                } else if (sum < 0)
                    L++;
                else if (sum > 0)
                    R--;
            }
        }
        return ans;
    }
}
```

###### 18、四数之和

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        if (nums == null || len < 4)
            return res;
        for (int i = 0; i < len - 3; i++) {
            for (int j = i + 1; j < len - 2; j++) {
                int L = j + 1;
                int R = len - 1;
                while (L < R) {
                    int sum = nums[j] + nums[L] + nums[R];
                    if (sum == (target - nums[i])) {
                        List temp = Arrays.asList(nums[i], nums[j], nums[L], nums[R]);
                        if (!res.contains(temp)) {
                            res.add(temp);
                        }
                        while (L < R && nums[L] == nums[L + 1])
                            L++;
                        while (L < R && nums[R] == nums[R - 1])
                            R--;
                        L++;
                        R--;
                    } else if (sum < (target - nums[i]))
                        L++;
                    else if (sum > (target - nums[i]))
                        R--;
                }
            }
        }
        return res;

    }
}
```



### 图

## 字符串

###### 524、通过删除字符匹配到字典里的最长单词

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421093258609.png" style="zoom:80%;" />

```java
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String longest = "";
        for(String target : dictionary){
            int l1 = longest.length(),l2 = target.length();
            if((l1 >l2) || ((l1==l2) &&longest.compareTo(target)<0) ) continue;
            if (issubstring(s,target)) longest = target;
        }
        return longest;
    }
    //双指针判断 target 是不是 s的字串
    private boolean issubstring(String s,String target){
        int i = 0,j=0;
        while(i<s.length() && j<target.length()){
            if(s.charAt(i) == target.charAt(j)){    
                j++;
            }
            i++;
        }
        return j == target.length();
    }
}
```

##### [KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

###### 部分匹配表

“部分匹配值”就是“前缀”和后缀的最长共有元素的长度。以“ABCDABD”为例。

```text
　　－　"A"的前缀和后缀都为空集，共有元素的长度为0；

　　－　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；

　　－　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；

　　－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；

　　－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；

　　－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；

　　－　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。
```

得到部分匹配表

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210506192613.png" style="zoom:50%;" />



当字符不匹配时
$$
移动位数 = 已匹配的字符数 - 对应的部分匹配值
$$


**KMP代码实现**

```

```



## 布隆过滤器

1.什么是布隆过滤器？

首先，我们需要了解布隆过滤器的概念。

布隆过滤器（Bloom Filter）是 Bloom 于1970年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，**存放在布隆过滤器的数据不容易删除。**

![](https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618916946286.png)

位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。

总结： Bloom 提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。

2.布隆过滤器的原理介绍

当一个元素加入布隆过滤器中的时候，会进行如下操作：

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

举个简单的例子：

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image002-1618916946286.png" style="zoom:50%;" />

如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由**多个哈希函数生成不同的哈希值**，然后在对应的位数组的下表的元素设置为 1（当位数组初始化时 ，所有位置均为0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。

如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。

综上，我们可以得出：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

3.布隆过滤器使用场景

1. 判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。
2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。

4.通过 Java 编程手动实现布隆过滤器

我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。

如果你想要手动实现一个的话，你需要：

1. 一个合适大小的位数组保存数据
2. 几个不同的哈希函数
3. 添加元素到位数组（布隆过滤器）的方法实现
4. 判断给定元素是否存在于位数组（布隆过滤器）的方法实现。

下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：

```java
1 	import java.util.BitSet;
2 	public class MyBloomFilter {
3 	/**
4 	     * 位数组的大小
5 	     */
6 	    private static final int DEFAULT_SIZE = 2 << 24;
7 	    /**
8 	     * 通过这个数组可以创建 6 个不同的哈希函数
9 	     */

10 	    private static final int[] SEEDS = new int[]{3, 13, 46, 71, 91, 134};
11 	/**
12 	     * 位数组。数组中的元素只能是 0 或者 1
13 	     */
14 	    private BitSet bits = new BitSet(DEFAULT_SIZE);
15 	/**
16 	     * 存放包含 hash 函数的类的数组
17 	     */
18 	    private SimpleHash[] func = new SimpleHash[SEEDS.length];
19 	/**
20 	     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样
21 	     */
22 	    public MyBloomFilter() {
23 	        // 初始化多个不同的 Hash 函数
24 	        for (int i = 0; i < SEEDS.length; i++) {
25 	            func[i] = new SimpleHash(DEFAULT_SIZE, SEEDS[i]);
26 	        }
27 	    }
28 	/**
29 	     * 添加元素到位数组
30 	     */
31 	    public void add(Object value) {
32 	        for (SimpleHash f : func) {
33 	            bits.set(f.hash(value), true);
34 	        }
35 	    }
36 	/**
37 	     * 判断指定元素是否存在于位数组
38 	     */
39 	    public boolean contains(Object value) {
40 	        boolean ret = true;
41 	        for (SimpleHash f : func) {
42 	            ret = ret && bits.get(f.hash(value));
43 	        }
44 	        return ret;
45 	    }
46 	/**
47 	     * 静态内部类。用于 hash 操作！
48 	     */
49 	    public static class SimpleHash {
50 	private int cap;
51 	        private int seed;
52 	public SimpleHash(int cap, int seed) {
53 	            this.cap = cap;
54 	            this.seed = seed;
55 	        }
56 	/**
57 	         * 计算 hash 值
58 	         */
59 	        public int hash(Object value) {
60 	            int h;
61 	            return (value == null) ? 0 : Math.abs(seed * (cap - 1) & ((h = value.hashCode()) ^ (h >>> 16)));
62 	        }
63 	}
64 	}
```

测试：

```java
    1 	        String value1 = "https://javaguide.cn/";
    2 	        String value2 = "https://github.com/Snailclimb";
    3 	        MyBloomFilter filter = new MyBloomFilter();
    4 	        System.out.println(filter.contains(value1));
    5 	        System.out.println(filter.contains(value2));
    6 	        filter.add(value1);
    7 	        filter.add(value2);
    8 	        System.out.println(filter.contains(value1));
    9 	        System.out.println(filter.contains(value2));
```

Output:

```java
    1 	false
    2 	false
    3 	true
    4 	true
```

测试：

```java
    1 	        Integer value1 = 13423;
    2 	        Integer value2 = 22131;
    3 	        MyBloomFilter filter = new MyBloomFilter();
    4 	        System.out.println(filter.contains(value1));
    5 	        System.out.println(filter.contains(value2));
    6 	        filter.add(value1);
    7 	        filter.add(value2);
    8 	        System.out.println(filter.contains(value1));
    9 	        System.out.println(filter.contains(value2));
```

Output:

```java
    1 	false
    2 	false
    3 	true
    4 	true
```

## 排序算法

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210424191133.png" style="zoom:50%;" />

##### 冒泡排序

```java
private static void bubble(int[] arr){
   for(int i = 0;i<arr.length-1;i++){  //遍历次数
      for(int j = 0;j<arr.length-1-i;j++){  //两两比较
         if(arr[j]>arr[j+1]){
              int temp = arr[j+1];
              arr[j+1] = arr[j];
              arr[j] = temp;
           }
       }
    }
}
```

优化

```java
public static void bubbleSort(int[] arr) {
  // 排序过程
   int temp = 0;
   boolean flag = false; // 标识变量，表示是否有交换
   for (int i = 0; i < arr.length - 1; i++) {
     for (int j = 0; j < arr.length - 1 - i; j++) {
          if (arr[j] > arr[j + 1]) {
            flag = true;
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
         }
   }
   if (!flag) { // 在一趟排序中，一次交换都没有发生
          break;
      } else {
          flag = false;
     }
   }
}
```

##### 选择排序

```java
// 选择排序
public static void selectSort(int[] arr) {
  for (int i = 0; i < arr.length - 1; i++) {
     int min = arr[i];
     int minIndex = i;
     for (int j = i + 1; j < arr.length; j++) {
         if (min > arr[j]) {
          min = arr[j];
          minIndex = j;
         }
    }
     if (minIndex != i) {
      arr[minIndex] = arr[i];
          arr[i] = min;
     }
  }
}
```

##### 插入排序

```java
// 插入排序
public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int insertVal = arr[i];
        int insertIndex = i - 1;
        while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
            arr[insertIndex + 1] = arr[insertIndex];
            insertIndex--;
       }
       if (insertIndex + 1 != i)
            arr[insertIndex + 1] = insertVal;
    }
}
```

##### 希尔排序

```java
// 交换式希尔排序
public static void shellSort(int[] arr) {
  int gap = arr.length / 2;
  int temp = 0;
    while (gap > 0) {
        for (int i = gap; i < arr.length; i++) {
            for (int j = i - gap; j >= 0; j -= gap) {
                if (arr[j] > arr[j + gap]) {
                    temp = arr[j];
                    arr[j] = arr[j + gap];
                    arr[j + gap] = temp;
                }
            }
        }
       gap = gap / 2;
    }
}
 // 移位式希尔排序
public static void shellSort2(int[] arr) {
   int gap = arr.length / 2;
    int temp = 0;
    while (gap > 0) {
       for (int i = gap; i < arr.length; i++) {
            int j = i;
           temp = arr[j];
            if (arr[j] < arr[j - gap]) {
              while (j - gap >= 0 && temp < arr[j - gap]) {
                    arr[j] = arr[j - gap];
        }
        gap = gap / 2;
    }
}
```

##### 快速排序

```java
public static void quickSort(int[] arr,int left,int right){
    int l = left;
    int r = right;
    int temp = 0;
    int pivot = arr[(left+right)/2];
    while(l <r){
        while(arr[l] <pivot){
            l+=1;
        }
        while(arr[r] >pivot){
            r-=1;
        }
        if(l>=r) break;

        temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;
        if(arr[l] == pivot){
            r-=1;
        }
        if(arr[r] == pivot){
            l+=1;
        }
    }
    if(l == r){
        l+=1;
        r-=1;
    }
    if(left<r){
        quickSort(arr,left,r);
    }
    if(right>l){
        quickSort(arr,l,right);
    }
}
```

##### 归并排序

```java
// 分+和
public static void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid, temp);
        mergeSort(arr, mid + 1, right, temp);
        // 合并
        merge(arr, left, mid, right, temp);
    }
}

// 合并的方法
public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left; // 初始化i，左边有序序列的初始索引
    int j = mid + 1; // 初始化j，右边有序序列的初始索引
    int t = 0; // 指向temp数组的当前索引
    // (一)
    // 先把左右两边（有序）的数据按照规则填充到temp中
    // 直到左右两边的有序序列，有一边处理完毕为止

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[t] = arr[i];
            t += 1;
            i += 1;
        } else {
            temp[t] = arr[j];
            t += 1;
            j += 1;
        }
    }
    // (二)
    // 把剩余数据的一边的数据依次全部填充到temp
    while (i <= mid) { // 左边有序序列还有剩余
        temp[t] = arr[i];
        t += 1;
        i += 1;
    }
    while (j <= right) {
        temp[t] = arr[j];
        t += 1;
        j += 1;
    }
    // (三)
    // 将temp数组的元素拷贝到arr
    // 每次拷贝部分
    t = 0;
    int tempLeft = left;
    while (tempLeft <= right) {
        arr[tempLeft] = temp[t];
        t += 1;
        tempLeft += 1;
    }
}
```



##### 桶排序

###### 347、前K个高频元素

```html
Given [1,1,1,2,2,3] and k = 2, return [1,2].
```

设置若干个桶，每个桶中存储出现频率相同的数。桶的小标表示数出现的频率，即第i个桶中存储的数出现的频率为i。

把数都放入桶之后，从后往前遍历桶，最先得到的K个数就是出现频率最多的K个数。

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> frequencyForNum = new HashMap<>();
    for (int num : nums) {
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    }                                                              //map中的Key为出现的数，value为对应出现的频率
    List<Integer>[] buckets = new ArrayList[nums.length + 1];     //尽可能大即可，能够存储所有的数
    for (int key : frequencyForNum.keySet()) {                 //桶中存储对应下表频率的数
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) {
            buckets[frequency] = new ArrayList<>();
        }
        buckets[frequency].add(key);
    }
    List<Integer> topK = new ArrayList<>();
    for (int i = buckets.length - 1; i >= 0 && topK.size() < k; i--) {
        if (buckets[i] == null) {
            continue;
        }
        if (buckets[i].size() <= (k - topK.size())) {
            topK.addAll(buckets[i]);
        } else {
            topK.addAll(buckets[i].subList(0, k - topK.size()));
        }
    }
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = topK.get(i);
    }
    return res;
}
```

###### 451、根据字符出现频率排序

```html
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

```java
public String frequencySort(String s) {
    Map<Character, Integer> frequencyForNum = new HashMap<>();
    for (char c : s.toCharArray())
        frequencyForNum.put(c, frequencyForNum.getOrDefault(c, 0) + 1);

    List<Character>[] frequencyBucket = new ArrayList[s.length() + 1];
    for (char c : frequencyForNum.keySet()) {
        int f = frequencyForNum.get(c);
        if (frequencyBucket[f] == null) {
            frequencyBucket[f] = new ArrayList<>();
        }
        frequencyBucket[f].add(c);
    }
    StringBuilder str = new StringBuilder();
    for (int i = frequencyBucket.length - 1; i >= 0; i--) {
        if (frequencyBucket[i] == null) {
            continue;
        }
        for (char c : frequencyBucket[i]) {
            for (int j = 0; j < i; j++) {
                str.append(c);
            }
        }
    }
    return str.toString();
}
```

##### 基数排序

```java
// 基数排序
public static void radixSort(int arr[]) {
    System.out.println("基数排序，arr长度:" + arr.length);
    // 1. 得到数组中最大的数的位数
    int max = arr[0]; // 假设第一数就是最大数
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    // 得到最大数是几位数
    int maxLength = (max + "").length();

    // 定义一个二维数组，表示10个桶, 每个桶就是一个一维数组
    // 说明
    // 1. 二维数组包含10个一维数组
    // 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length
    // 3. 名明确，基数排序是使用空间换时间的经典算法
    int[][] bucket = new int[10][arr.length];

    // 为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数
    // 可以这里理解
    // 比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数
    int[] bucketElementCounts = new int[10];

    // 这里我们使用循环将代码处理
    for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
        // (针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..
        for (int j = 0; j < arr.length; j++) {
            // 取出每个元素的对应位的值
            int digitOfElement = arr[j] / n % 10;
            // 放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        int index = 0;
        // 遍历每一桶，并将桶中数据，放入到原数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            // 如果桶中，有数据，我们才放入到原数组
            if (bucketElementCounts[k] != 0) {
                // 循环该桶即第k个桶(即第k个一维数组), 放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    // 取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }
            // 第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！
            bucketElementCounts[k] = 0;

        }
    }
}
```

##### 计数排序

```java
private static void countingsort(int[] arr){
    //计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内
    //1.找到数组内的最大值
   int maxValue = arr[0];
   for(int value : arr){
        if(maxValue<value){
        maxValue = value;
        }
    }
//创建数组计数
    int bucketlen = maxValue+1;
    int[] bucket = new int[bucketlen];
// bucket数组中的索引为arr中的元素，值为元素的个数
    for(int value : arr){
        bucket[value]++;
    }
    int sortedIndex = 0;
    for(int j = 0;j<bucketlen;j++){
        while(bucket[j]>0){
            arr[sortedIndex++] = j;
            bucket[j] --;
        }
    }
}
```

##### [堆排序](https://mp.weixin.qq.com/s/DCBmu0Zu9dX3hx_L3903bA)



##### 荷兰国旗问题

荷兰国旗包含三种颜色：红、白、蓝。

有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png)

###### 75、颜色分类

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421103325680.png)

```html
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

```java
public void sortColors(int[] nums) {
    int zero = -1, one = 0, two = nums.length;
    while (one < two) {
        if (nums[one] == 0) {
            swap(nums, ++zero, one++);
        } else if (nums[one] == 2) {
            swap(nums, --two, one);
        } else {
            ++one;
        }
    }
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

## 贪心思想

保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。

###### 455、分配饼干

```html
Input: grid[1,3], size[1,2,4]
Output: 2
```

题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。

1. 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。
2. 因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。

```java
public int findContentChildren(int[] grid, int[] size) {
    if (grid == null || size == null) return 0;
    Arrays.sort(grid);
    Arrays.sort(size);
    int gi = 0, si = 0;
    while (gi < grid.length && si < size.length) {
        if (grid[gi] <= size[si]) {
            gi++;
        }
        si++;
    }
    return gi;
}
```

###### 435、无重叠区间

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421105455953.png)

先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。

在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。

按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if(intervals.length == 0) return 0;
    Arrays.sort(intervals,new Comparator<int[]>(){
        public int compare(int[] o1,int[] o2){
            return o1[1]-o2[1];
        }
    });
    int count = 1;
    int end = intervals[0][1];
    for(int i = 1;i<intervals.length;i++){
        if(intervals[i][0]<end) continue;
        count++;
        end = intervals[i][1];
    }
    return intervals.length -count;
}
```
###### 406、根据身高重建队列

```html
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。

为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。

身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。

```java
public int[][] reconstructQueue(int[][] people) {
    Arrays.sort(people,new Comparator<int[]>(){
        public int compare(int[] o1,int[] o2){
            if(o1[0] != o2[0]){
                return o2[0] -o1[0];
            }else{
                return o1[1] -o2[1];
            }
        }
    });
    List<int[]> list = new ArrayList<>();
    for(int[] p : people){
        list.add(p[1],p);
    }
    return list.toArray(new int[list.size()][]);
}
```
###### 121、买卖股票的最佳时机

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421110622958.png)

**贪心**：只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if (n == 0) return 0;
    int soFarMin = prices[0];
    int max = 0;
    for (int i = 1; i < n; i++) {
        if (soFarMin > prices[i]) soFarMin = prices[i];   //记录最小元素
        else max = Math.max(max, prices[i] - soFarMin);
    }
    return max;
}
```

**动态规划**：

###### 122、买卖股票的最佳时机II

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421112057592.png)

对于 [a, b, c, d]，如果有 a <= b <= c <= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] > 0，那么就把 prices[i] - prices[i-1] 添加到收益中。

```java
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            profit += (prices[i] - prices[i - 1]);
        }
    }
    return profit;
}
```

###### 665、非递减数列

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421113104869.png)

在出现 nums[i] < nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 **不影响后续的操作** 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] < nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。

```java
public boolean checkPossibility(int[] nums) {
    int count =0;
    for(int i = 1;i<nums.length && count<2;i++){
        if(nums[i-1]<=nums[i]) continue;
        count++;
        if(i-2>=0 && nums[i-2] >nums[i]){
            nums[i] = nums[i-1];
        }else{
            nums[i-1] =nums[i];
        }
    }
    return count<=1;
}
```
## [分治](https://mp.weixin.qq.com/s/a3_bMRmTqZxMBruYsPC9-w)

分：递归解决较小问题

治：递归求解，如果问题够小直接求解

合并：将子问题的解构建父类问题

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/852a613f0b44463041105495d1ae6a65.png" style="zoom:50%;" />

**子问题完全独立：**

#### 二分搜索

#### 快速排序

快排也是分治的一个实例，快排每一趟会选定一个数，将比这个数小的放左面，比这个数大的放右面，然后递归分治求解两个子区间，当然快排因为在分的时候就做了很多工作，当全部分到最底层的时候这个序列的值就是排序完的值。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/420e9c9db595e573a4ea8b388c5a8030.png)

```java
public void quicksort(int [] a,int left,int right)
{
  int low=left;
  int high=right;
  //下面两句的顺序一定不能混，否则会产生数组越界！！！very important！！！
  if(low>high)//作为判断是否截止条件
    return;
  int k=a[low];//额外空间k，取最左侧的一个作为衡量，最后要求左侧都比它小，右侧都比它大。
  while(low<high)//这一轮要求把左侧小于a[low],右侧大于a[low]。
  {
    while(low<high&&a[high]>=k)//右侧找到第一个小于k的停止
    {
      high--;
    }
    //这样就找到第一个比它小的了
    a[low]=a[high];//放到low位置
    while(low<high&&a[low]<=k)//在low往右找到第一个大于k的，放到右侧a[high]位置
    {
      low++;
    }
    a[high]=a[low];   
  }
  a[low]=k;//赋值然后左右递归分治求之
  quicksort(a, left, low-1);
  quicksort(a, low+1, right);  
}
```

#### 归并排序（逆序数）

快排在分的时候做了很多工作，而归并就是相反，归并在分的时候按照数量均匀分，而合并时候已经是两两有序的进行合并的，因为两个有序序列O(n)级别的复杂度即可得到需要的结果。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/5b980538878b7a97167d9a8ba9c0805d.png" style="zoom:50%;" />

```java
private static void mergesort(int[] array, int left, int right) {
  int mid=(left+right)/2;
  if(left<right)
  {
    mergesort(array, left, mid);
    mergesort(array, mid+1, right);
    merge(array, left,mid, right);
  }
}

private static void merge(int[] array, int l, int mid, int r) {
  int lindex=l;int rindex=mid+1;
  int team[]=new int[r-l+1];
  int teamindex=0;
  while (lindex<=mid&&rindex<=r) {//先左右比较合并
    if(array[lindex]<=array[rindex])
    {
      team[teamindex++]=array[lindex++];
    }
    else {    
      team[teamindex++]=array[rindex++];
    }
  }
  while(lindex<=mid)//当一个越界后剩余按序列添加即可
  {
    team[teamindex++]=array[lindex++];

  }
  while(rindex<=r)
  {
    team[teamindex++]=array[rindex++];
  } 
  for(int i=0;i<teamindex;i++)
  {
    array[l+i]=team[i];
  }
}
```



###### 241、为运算表达式设计优先级

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421142554119.png)

```html
Input: "2-1-1".

((2-1)-1) = 0
(2-(1-1)) = 2

Output : [0, 2]
```

```java
public List<Integer> diffWaysToCompute(String input) {
    List<Integer> ways = new ArrayList<>();         //存储结果
    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        if (c == '+' || c == '-' || c == '*') {
            List<Integer> left = diffWaysToCompute(input.substring(0, i));
            List<Integer> right = diffWaysToCompute(input.substring(i + 1));
            for (int l : left) {
                for (int r : right) {
                    switch (c) {
                        case '+':
                            ways.add(l + r);
                            break;
                        case '-':
                            ways.add(l - r);
                            break;
                        case '*':
                            ways.add(l * r);
                            break;
                    }
                }
            }
        }
    }
    if (ways.size() == 0) {
        ways.add(Integer.valueOf(input));
    }
    return ways;
}
```

###### 95、不同的二叉搜索树II

给定一个数字 n，要求生成所有值为 1...n 的二叉搜索树。

```html
Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

```java
public List<TreeNode> generateTrees(int n) {
    if (n < 1) {
        return new LinkedList<TreeNode>();
    }
    return generateSubtrees(1, n);
}

private List<TreeNode> generateSubtrees(int s, int e) {
    List<TreeNode> res = new LinkedList<TreeNode>();
    if (s > e) {
        res.add(null);
        return res;
    }
    for (int i = s; i <= e; ++i) {
        List<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);
        List<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);
        for (TreeNode left : leftSubtrees) {
            for (TreeNode right : rightSubtrees) {
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }
    return res;
}
```



**子问题不完全独立：**

#### 最大子序列和

最大子序列和的问题我们可以使用动态规划的解法，但是也可以使用分治算法来解决问题，但是最大子序列和在合并的时候并不是简单的合并，因为子序列和涉及到一个长度的问题，所以正确结果不一定全在最左侧或者最右侧，而可能出现结果的区域为：

- 完全在中间的左侧
- 完全在中间的右侧
- 包含中间左右两个节点的一个序列

用一张图可以表示为：

![](https://gitee.com/sun-qiao321/picture/raw/master/images/fc9ffae299f8da5bdad5263e636f4194.png)

```java
public int maxSubArray(int[] nums) {
    int max=maxsub(nums,0,nums.length-1);
    return max;
}
int maxsub(int nums[],int left,int right)
{
    if(left==right)
        return  nums[left];
    int mid=(left+right)/2;
    int leftmax=maxsub(nums,left,mid);//左侧最大
    int rightmax=maxsub(nums,mid+1,right);//右侧最大

    int midleft=nums[mid];//中间往左
    int midright=nums[mid+1];//中间往右
    int team=0;
    for(int i=mid;i>=left;i--)
    {
        team+=nums[i];
        if(team>midleft)
            midleft=team;
    }
    team=0;
    for(int i=mid+1;i<=right;i++)
    {
        team+=nums[i];
        if(team>midright)
            midright=team;
    }
    int max=midleft+midright;//中间的最大值
    if(max<leftmax)
        max=leftmax;
    if(max<rightmax)
        max=rightmax;
    return  max;
}
```



## 搜索

#### BFS（广度优先搜索）

###### 1091、二进制矩阵中的最短路径

```html
[[1,1,0,1],
 [1,0,1,0],
 [1,1,1,1],
 [1,0,1,1]]
```

题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。

最短路径问题：通常广度优先搜索

```java
public int shortestPathBinaryMatrix(int[][] grids){
    if(grids == null || grids.length == 0 || grids[0].length == 0) return -1; //处理边界条件
    int[][] directions = {{1,-1},{1,0},{1,1},{0,-1},{0,1},{-1,-1},{-1,0},{-1,1}};  //搜索方向
    int m = grids.length, n = grids[0].length;
    Queue<int[]> queue = new LinkedList<>();
    queue.add(new int[]{0,0});     //输入头节点
    int pathSize = 0;             //遍历层数
    while(!queue.isEmpty()){
        int size = queue.size();
        pathSize++;
        while(size-- >0){
            int[] cur = queue.poll();
            if(grids[cur[0]][cur[1]] == 1) continue;
            if(cur[0] == m-1 && cur[1] == n-1) return pathSize;
            grids[cur[0]][cur[1]] = 1;
            for(int[] d : directions){
                int nr = cur[0] + d[0], nc = cur[1] + d[1];
                if(nr<0 || nr>=m || nc<0 || nc>=n) continue;
                queue.add(new int[]{nr,nc});
            }
        }
    }
    return -1;
}
```



###### 279、完全平方数

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421182105441.png)

可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。

要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。

本题也可以用动态规划求解，在之后动态规划部分中会再次出现。

```java
public int numSquares(int n) {
    List<Integer> squares = generateSquares(n);
    Queue<Integer> queue = new LinkedList<>();
    boolean[] marked = new boolean[n + 1];
    queue.add(n);
    marked[n] = true;
    int level = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        level++;
        while (size-- > 0) {
            int cur = queue.poll();
            for (int s : squares) {
                int next = cur - s;
                if (next < 0) {
                    break;
                }
                if (next == 0) {
                    return level;
                }
                if (marked[next]) {
                    continue;
                }
                marked[next] = true;
                queue.add(next);
            }
        }
    }
    return n;
}

/**
 * 生成小于 n 的平方数序列
 * @return 1,4,9,...
 */
private List<Integer> generateSquares(int n) {
    List<Integer> squares = new ArrayList<>();
    int square = 1;
    int diff = 3;
    while (square <= n) {
        squares.add(square);
        square += diff;
        diff += 2;
    }
    return squares;
}
```



#### DFS（深度优先搜索）

##### 岛屿问题：

简单树的DFS遍历：

```java
void traverse(TreeNode root) {
    // 判断 base case
    if (root == null) {
        return;
    }
    // 访问两个相邻结点：左子结点、右子结点
    traverse(root.left);
    traverse(root.right);
}
```
类比到网格的遍历框架：

```java
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    // 如果坐标 (r, c) 超出了网格范围，直接返回
    if (!inArea(grid, r, c)) {
         return;
     }
     // 访问上、下、左、右四个相邻结点
     dfs(grid, r - 1, c);
     dfs(grid, r + 1, c);

     dfs(grid, r, c - 1);
     dfs(grid, r, c + 1);
 }
 	
 // 判断坐标 (r, c) 是否在网格中
 boolean inArea(int[][] grid, int r, int c) {
     return 0 <= r && r < grid.length 
                 && 0 <= c && c < grid[0].length;
 }
```

避免重复：

```java
1 	void dfs(int[][] grid, int r, int c) {
2 	    // 判断 base case
3 	    if (!inArea(grid, r, c)) {
4 	        return;
5 	    }
6 	    // 如果这个格子不是岛屿，直接返回
7 	    if (grid[r][c] != 1) {
8 	        return;
9 	    }
10 	    grid[r][c] = 2; // 将格子标记为「已遍历过」
11 	    
12 	    // 访问上、下、左、右四个相邻结点
13 	    dfs(grid, r - 1, c);
14 	    dfs(grid, r + 1, c);
15 	    dfs(grid, r, c - 1);
16 	    dfs(grid, r, c + 1);
17 	}
18 	
19 	// 判断坐标 (r, c) 是否在网格中
20 	boolean inArea(int[][] grid, int r, int c) {
21 	    return 0 <= r && r < grid.length 
22 	                && 0 <= c && c < grid[0].length;
23 	}
```

###### 200、岛屿数量

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421200933425.png)

```java
public int numIslands(char[][] grid) {
    int count = 0;
    for(int i = 0;i<grid.length;i++){
        for(int j = 0;j<grid[0].length;j++){
            if(grid[i][j] == '1') {
                count++;
                dfs(grid,i,j);
            }
        }
    }
    return count;
}
private void dfs(char[][] grid,int r, int c){
    if(r<0|| r>= grid.length || c<0 || c>=grid[0].length) return;
    if(grid[r][c] !='1') return;
     grid[r][c] = '2';
     dfs(grid,r-1,c);
     dfs(grid,r+1,c);
     dfs(grid,r,c-1);
     dfs(grid,r,c+1);
}
```
###### 695、岛屿最大面积

```java
public int maxAreaOfIsland(int[][] grid) {
    int res = 0;
    for(int i = 0;i<grid.length;i++){
        for(int j = 0;j<grid[0].length;j++){
            if(grid[i][j] == 1) {
                int area = dfs(grid,i,j);
                res = Math.max(res,area);
            }
        }
    }
    return res;
}

private int dfs(int[][] grid,int r,int c){
    if(r<0 || r>=grid.length|| c<0||c>=grid[0].length){
        return 0;
    }
    if(grid[r][c] != 1) return 0;
    grid[r][c] =2;
    return 1
    +dfs(grid,r-1,c)
    +dfs(grid,r+1,c)
    +dfs(grid,r,c-1)
    +dfs(grid,r,c+1);
}
```
###### 463、岛屿周长

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421201417824.png" style="zoom:50%;" />

```java
public int islandPerimeter(int[][] grid) {
    for(int i = 0;i<grid.length;i++){
        for(int j = 0;j<grid[0].length;j++){
            if(grid[i][j] == 1){
                return dfs(grid,i,j);
            }
        }
    }
    return 0;
}
private int dfs(int[][] grid,int r,int c){
    if(r<0||r>=grid.length||c<0||c>=grid[0].length){
        return 1;
    }
    if(grid[r][c] == 0) return 1;
    if(grid[r][c] != 1) return 0;
    grid[r][c] = 2;
    return dfs(grid,r-1,c)
    +dfs(grid,r+1,c)
    +dfs(grid,r,c-1)
    +dfs(grid,r,c+1);
}
```
###### 547、省份数量

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210421202014347.png" style="zoom:50%;" />

```java
private int n;

public int findCircleNum(int[][] M) {
    n = M.length;
    int circleNum = 0;
    boolean[] hasVisited = new boolean[n];
    for (int i = 0; i < n; i++) {
        if (!hasVisited[i]) {
            dfs(M, i, hasVisited);
            circleNum++;
        }
    }
    return circleNum;
}

private void dfs(int[][] M, int i, boolean[] hasVisited) {
    hasVisited[i] = true;
    for (int k = 0; k < n; k++) {
        if (M[i][k] == 1 && !hasVisited[k]) {
            dfs(M, k, hasVisited);
        }
    }
}
```

###### 130、被围绕的区域

```html
For example,
X X X X
X O O X
X X O X
X O X X

After running your function, the board should be:
X X X X
X X X X
X X X X
X O X X
```

题目描述：使被 'X' 包围的 'O' 转换为 'X'。

先填充最外侧，剩下的就是里侧了。

```java
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
private int m, n;

public void solve(char[][] board) {
    if (board == null || board.length == 0) {
        return;
    }

    m = board.length;
    n = board[0].length;

    for (int i = 0; i < m; i++) {
        dfs(board, i, 0);
        dfs(board, i, n - 1);
    }
    for (int i = 0; i < n; i++) {
        dfs(board, 0, i);
        dfs(board, m - 1, i);
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'T') {
                board[i][j] = 'O';
            } else if (board[i][j] == 'O') {
                board[i][j] = 'X';
            }
        }
    }
}

private void dfs(char[][] board, int r, int c) {
    if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] != 'O') {
        return;
    }
    board[r][c] = 'T';
    for (int[] d : direction) {
        dfs(board, r + d[0], c + d[1]);
    }
}
```



## 回溯

三部曲：

- 回溯函数的返回值以及参数
- 终止条件：搜到叶子节点
- 回溯搜索的遍历过程

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/e8500d0e7b963a8dbf29e12c6d1b7d41.png" style="zoom:50%;" />

#### 组合

###### 77、组合

给定两个整数n 和 k，返回1...n 中可能的k个数的组合

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
    private void backtracking(int n,int k,int startindex){   //startindex 用来标记
        if(path.size() == k){
            result.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = startindex;i<=n-(k-path.size())+1;i++){  //剪枝
            path.add(i);
            backtracking(n,k,i+1);
            path.remove(path.size()-1);
        }
    }
}
```

###### 39、组合总和

给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

* `candidates` 中的数字可以无限制重复被选取。

注意：与数对和是有区别的，本题不限制个数，所以无法判断遍历几次。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backstacking(candidates,target,0,0);
        return result;
    }
    private void backstacking(int[] candidates,int target,int num,int startindex){
        if(num>target) return;
        if(num == target){
            result.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = startindex;i<candidates.length;i++){
            num+=candidates[i];
            path.add(candidates[i]);
            backstacking(candidates,target,num,i);
            num-=candidates[i];
            path.remove(path.size()-1);
        }
    }
}
```

###### 40、组合总和II

给定一个数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用一次。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        boolean[] used = new boolean[candidates.length];
        for(int i = 0;i<used.length;i++){
            used[i] = false;
        }
        Arrays.sort(candidates);
        backtracking(candidates,target,0,0,used);
        return result;
    }
    private void backtracking(int[] candidates,int target,int sum,int startindex,boolean[] used){
        if(sum==target){
            result.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = startindex;i<candidates.length&& sum+candidates[i]<=target;i++){
            if(i>0 && candidates[i]==candidates[i-1] && used[i-1]==false){
                continue;
            }
            sum+=candidates[i];
            path.add(candidates[i]);
            used[i]=true;
            backtracking(candidates,target,sum,i+1,used);
            used[i]=false;
            sum-=candidates[i];
            path.remove(path.size()-1);
        }
    }
}
```

###### 216、组合总和III

找出所有相加之和为 ***n*** 的 **k**个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(k,n,0,1);
        return result;
    }
    private void backtracking(int k,int n,int sum,int startindex){
        if(sum>n) return;
        if(path.size() == k){
            if(sum == n) result.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = startindex;i<=9;i++){
            sum+=i;
            path.add(i);
            backtracking(k,n,sum,i+1);
            sum-=i;
            path.remove(path.size()-1);
        }
    }
}
```



#### 分割

###### 131、分割回文子串

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

```java
class Solution {
    List<List<String>> result = new ArrayList<List<String>>();
    List<String> path = new ArrayList<>();
    public List<List<String>> partition(String s) {
        backtracking(s,0);
        return result;
    }

    private void backtracking(String s,int startindex){
       if(startindex>=s.length()){
           result.add(new ArrayList<String>(path));
           return;
       }
       for(int i = startindex;i<s.length();i++){
           if(isPalindrome(s,startindex,i)){
               String str = s.substring(startindex,i+1);
               path.add(str);
           }else{
               continue;
           }
           backtracking(s,i+1);
           path.remove(path.size()-1);
       }
    }

    private boolean isPalindrome(String s,int start,int end){
        for(int i = start,j=end;i<j;i++,j--){
            if(s.charAt(i) != s.charAt(j)){
                return false;
            }
        }
        return true;
    }
}
```

#### 子集

###### 78、子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums,0);
        return result;
    }
    private void backtracking(int[] nums, int startIndex){
        result.add(new ArrayList<Integer>(path));
        if(startIndex>=nums.length){
            return;
        }
        for(int i = startIndex;i<nums.length;i++){
            path.add(nums[i]);
            backtracking(nums,i+1);
            path.remove(path.size()-1);
        }
    }
}
```

###### 90、子集II

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path  = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        boolean[] used = new boolean[nums.length];
        for(int i=0;i<used.length;i++){
            used[i] = false;
        }   
        Arrays.sort(nums);
        backtracking(nums,0,used);
        return result;
    }
    private void backtracking(int[] nums,int startIndex,boolean[] used){
        result.add(new ArrayList<Integer>(path));
        for(int i = startIndex;i<nums.length;i++){
            if(i>0 && nums[i]==nums[i-1] && used[i-1]==false){
                continue;
            }
            path.add(nums[i]);
            used[i]=true;
            backtracking(nums,i+1,used);
            used[i]=false;
            path.remove(path.size()-1);
        }
    }
}
```

###### 491、递增子序列

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums,0);
        return result;
    }
    private void backtracking(int[] nums,int startIndex){
        if(path.size()>=2){
            result.add(new ArrayList<Integer>(path));
        }
        Set<Integer> set = new HashSet<>();
        for(int i = startIndex;i<nums.length;i++){
            if((!path.isEmpty() && nums[i]<path.get(path.size()-1)) ||set.contains(nums[i])){
                continue;
            }
            set.add(nums[i]);
            path.add(nums[i]);
            backtracking(nums,i+1);
            path.remove(path.size()-1);
        }
    }
}
```

#### 排列

###### 46、全排列

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        boolean[] used = new boolean[nums.length];
        for(boolean boo:used){
            boo = false;
        }
        backtracking(nums,used);
        return result;
    }
    private void backtracking(int[] nums,boolean[] used){
        if(path.size()==nums.length){
             result.add(new ArrayList<Integer>(path));
             return;
        }
        for(int i = 0;i<nums.length;i++){
            if(used[i]==true) continue;
            used[i]=true;
            path.add(nums[i]);
            backtracking(nums,used);
            used[i]=false;
            path.remove(path.size()-1);
        }
    }
}
```

###### 47、全排列II

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

```java
class Solution {
    boolean[] vis;

    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> perm = new ArrayList<Integer>();
        vis = new boolean[nums.length];
        Arrays.sort(nums);
        backtrack(nums, ans, 0, perm);
        return ans;
    }

    public void backtrack(int[] nums, List<List<Integer>> ans, int idx, List<Integer> perm) {
        if (idx == nums.length) {
            ans.add(new ArrayList<Integer>(perm));
            return;
        }
        for (int i = 0; i < nums.length; ++i) {
            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {
                continue;
            }
            perm.add(nums[i]);
            vis[i] = true;
            backtrack(nums, ans, idx + 1, perm);
            vis[i] = false;
            perm.remove(idx);
        }
    }
}
```



## 动态规划

- 确定dp数组以及下标的含义
- 确定递推公式
- dp数组如何初始化
- 确定遍历顺序
- 举例推导dp数组

###### 62、不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

1.dp[i] [j] 表示从(0,0)出发到达( i , j) 位置时路径数

2.因为只能下，右走，所以前一个状态为 dp[i-1] [j] 或 dp[i] [j-1]

  dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]

3.dp[i] [0] = 1, dp[0] [j] = 1

4.从左至右

5.举例

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i = 0;i<m;i++){
            dp[i][0] = 1;
        }
        for(int j = 0;j<n;j++){
            dp[0][j] = 1;
        }
        for(int i = 1;i<m;i++){
            for(int j =1;j<n;j++){
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

###### 63、不同路径II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

1.dp[i] [j] 表示从(0,0)出发到达( i , j) 位置时路径数

2.因为只能下，右走，所以前一个状态为 dp[i-1] [j] 或 dp[i] [j-1]

  dp[i] [j] = dp[i-1] [j] + dp[i] [j-1] 。有了障碍，(i,j)障碍位置应该为0.

3.dp[i] [0] = 1, dp[0] [j] = 1  ，障碍之后为0

4.从左至右

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        for(int i = 0;i<m &&obstacleGrid[i][0]==0;i++) dp[i][0]=1;
        for(int j = 0;j<n&&obstacleGrid[0][j]==0;j++) dp[0][j]=1;
        for(int i = 1;i<m;i++){
            for(int j =1;j<n;j++){
                if(obstacleGrid[i][j]==1) continue;
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

###### 343、整数拆分

给定一个正整数 n，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。返回你可以获得的最大乘积。

1.dp[i] 为 正整数 i 拆分两个数后的最大乘积

2.当 i ≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤ j< i），则有以下两种方案：

将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j × (i−j)；

将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。

dp[i] = max(dp[i] , max(  (i-j)*j) , dp[i-j] * j );

3.初始化 dp[0] =1，dp[1] = 1

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2]=1;
        for(int i = 3;i<=n;i++){
            for(int j = 1;j<i;j++){
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```

###### 96、不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

> 与上文分治算法搜索树的构造对比

1.**dp[i] ：1到i为节点组成的二叉搜索树的个数为dp[i]**。

2.dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

3.dp[0] = 1

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        
        for(int i = 2; i < n + 1; i++)
            for(int j = 1; j < i + 1; j++) 
                dp[i] += dp[j-1] * dp[i-j];
        
        return dp[n];
    }
}
```



###### 走n步回到0的走法

```java
//一个环上有10个点，编号为0-9，从0点出发，每步可以顺时针到下一个点，也可以逆时针到上一个点，求：经过n步又
//回到0点有多少种不同的走法
/*思路：dp[i][j] 表示 从j点出发走i步到达原点 0 的方法数。则dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1];
*由于是环的问题，j-1 和 j+1可能超出范围。因此递推式 为dp[i][j] = dp[i-1][(j-1+n)%n] + dp[i-1][(j+1)%n];
*/
public class steps {
    public static void main(String[] args) {
        System.out.println(getSteps(10, 6));
    }
    private static int getSteps(int n,int k){
        if (n ==0) return 1;
        int[][] dp = new int[100][100];
        dp[0][0] = 1;           //0点出发走0步 为1
        for (int j = 1;j<n;j++){
            dp[0][j] = 0;        //其他点出发走 0  步 为0
        }
        for(int i = 1;i<=k;i++){
            for(int j = 0;j<n;j++){
                dp[i][j] = dp[i-1][(j-1+n)%n] + dp[i-1][(j+1)%n];
            }
        }
        return dp[k][0];
    }
}
```



###### 摩斯电码解码

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210502144723.png" style="zoom:50%;" />

1.dp[i] 表示为 从 i 开始后面字符的解码方法数

2.i-1为 0 ，则该位是单字码，dp[i] = dp[i+1]

  i-1 为1，若为单字码，dp[i] = dp[i+1]

​                 若为双字码，dp[i] = dp[i] + dp[i+2] 

​                 若为三字码，dp[i] = dp[i] + dp[i+3]

```java
import java.io.*;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] str = br.readLine().toCharArray();
        int n = str.length;
        int[] dp = new int[n+1];
        dp[n] = 1;
        for(int i = n-1;i>=0;i--){
            dp[i] = dp[i+1];
            if(str[i] == '1'){
                if(i+2<=n) dp[i] = dp[i]+dp[i+2];
                if(i+3<=n) dp[i] = dp[i]+dp[i+3];
            }
        }
        System.out.println(dp[0]);
    }
}
```

###### 1262、可被三整除的最大和

给你一个整数数组 `nums`，请你找出并返回能被三整除的元素最大和。

1.dp[i] [0]表示到数组下标 i-1 为止，和为0的最大和

  dp[i] [1]表示到数组下标 i-1 为止，和为1的最大和

  dp[i] [2]表示到数组下标 i-1 为止，和为2的最大和

```java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n+1][3];
        dp[0][0] = 0;
        dp[0][1] = Integer.MIN_VALUE;
        dp[0][2] = Integer.MIN_VALUE;
        for(int i = 1;i<=n;i++){
            if(nums[i-1]%3 == 0){
                dp[i][0] = Math.max(dp[i-1][0],dp[i-1][0] +nums[i-1]);
                dp[i][1] = Math.max(dp[i-1][1],dp[i-1][1] +nums[i-1]);
                dp[i][2] = Math.max(dp[i-1][2],dp[i-1][2] +nums[i-1]);
            }else if(nums[i-1] %3 == 1) {
                dp[i][0] = Math.max(dp[i-1][0] ,dp[i-1][2] +nums[i-1]);
                dp[i][1] = Math.max(dp[i-1][1] ,dp[i-1][0] +nums[i-1]);
                dp[i][2] = Math.max(dp[i-1][2] ,dp[i-1][1] +nums[i-1]);
            }else if(nums[i-1] % 3 == 2){
                dp[i][0] = Math.max(dp[i-1][0] ,dp[i-1][1] +nums[i-1]);
                dp[i][1] = Math.max(dp[i-1][1] ,dp[i-1][2] +nums[i-1]);
                dp[i][2] = Math.max(dp[i-1][2] ,dp[i-1][0] +nums[i-1]);
            }
        }
        return dp[n][0];
    }
}

//简化
class Solution {
    public int maxSumDivThree(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n+1][3];
        dp[0][0] = 0;
        dp[0][1] = Integer.MIN_VALUE;
        dp[0][2] = Integer.MIN_VALUE;
        for(int i = 1;i<=n;i++){
            int x = nums[i-1] % 3;
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][(3-x)%3] +nums[i-1]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][(3-x+1)%3] +nums[i-1]);
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][(3-x+2)%3] +nums[i-1]);
        }
        return dp[n][0];
    }
}
```

同理，可被6整除的最大和为

```java
public static int maxSum(int[] nums){
    int n = nums.length;
    int[][] dp = new int[n+1][6];
    dp[0][0] = 0;
    dp[0][1] = Integer.MIN_VALUE;
    dp[0][2] = Integer.MIN_VALUE;
    dp[0][3] = Integer.MIN_VALUE;
    dp[0][4] = Integer.MIN_VALUE;
    dp[0][5] = Integer.MIN_VALUE;
    for(int i = 1;i<=n;i++){
        int x = nums[i-1]%6;
        dp[i][0] = Math.max(dp[i-1][0] ,dp[i-1][(6-x)%6] +nums[i-1]);
        dp[i][1] = Math.max(dp[i-1][1] ,dp[i-1][(6-x+1)%6] +nums[i-1]);
        dp[i][2] = Math.max(dp[i-1][2] ,dp[i-1][(6-x+2)%6] +nums[i-1]);
        dp[i][3] = Math.max(dp[i-1][3] ,dp[i-1][(6-x+3)%6] +nums[i-1]);
        dp[i][4] = Math.max(dp[i-1][4] ,dp[i-1][(6-x+4)%6] +nums[i-1]);
        dp[i][5] = Math.max(dp[i-1][5] ,dp[i-1][(6-x+5)%6] +nums[i-1]);
    }
    return dp[n][0];
}
```



#### 背包问题

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/2e150558181e3096077a584e3f9bf34f.png" style="zoom:80%;" />

##### 01背包

有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

1.dp[i] [j] **表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

2.如果取了第 i 件物品， 则dp[i] [j] = dp[i-1] [j - weight[i]] + value[i]；

  如果没取第 i 件物品，则 dp[i] [j] = dp[i-1] [j]

则递推式为 dp[i] [j] = max( dp[i-1] [j] , dp[i-1] [j-weight[i]] +value[i] )

3.如果背包容量j 为 0，即dp[i] [0] = 0；

  如果i= 0，即只选择物品0，各个容量的背包所能存放的最大价值

 

```java
// 倒叙遍历
for (int j = bagWeight; j >= weight[0]; j--) {
    dp[0][j] = dp[0][j - weight[0]] + value[0]; // 初始化i为0时候的情况
}
```

4.确定遍历顺序

先背包后物品或者先物品后背包



一维数组

1.dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2.取物品 i 则 dp[j] = dp[j - weight[i]] + value[i] ;

   不取物品 i dp[j] = dp[j - weight[i]]

dp [j] = max(dp[j] , dp[j - weight[i]] + value[i])

3.初始化 dp[0] = 0;

4.遍历

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

###### 46、分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

转化为背包问题：

背包大小为sum /2 

1.dp[j] 表示背包总和为 j ，能够装的最大子集和为 dp [j] 

2.dp[j] = max(dp[j], dp[j-nums[i]] +nums[i] )

3.dp[0] = 0

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sums = 0;
        int[] dp = new int[20001];
        for(int i = 0;i<nums.length;i++){
            sums+=nums[i];
        }
        if(sums%2 == 1) return false;
        int target = sums/2;
        for(int i = 0;i<nums.length;i++){
            for(int j = target;j>=nums[i];j--){
                dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        if(dp[target] == target) return true;
        return false;
    }
}
```

###### 494、目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

转化为背包问题：

设数组总和为 sum。

其中加法总和为 x，那么减法总和为 sum - x

即x - (sum -x) = S   ，则 x = (S + sum) /2。转化为装满 x 容量的背包有几种方法。

1.dp [j] 表示为填满容量为j 的背包，有dp[j] 种方法

2.dp[j] = dp[j] + dp[j - num]，
当前填满容量为j的包的方法数 = 之前填满容量为j的包的方法数 + 之前填满容量为j - num的包的方法数
也就是当前数num的加入，可以把之前和为j - num的方法数加入进来。

3.初始化 dp[0] = 1

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        if(S > sum) return 0;
        if((S + sum)%2 == 1) return 0;
        int target = (S + sum)/2;
        int[] dp = new int[target +1];
        dp[0] = 1;
        for(int i = 0;i<nums.length;i++){
            for(int j = target;j>= nums[i];j--){
                dp[j] = dp[j] + dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}
```

###### 474、一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

转化为背包问题：

strs 数组里的元素就是物品，且每种只有一个，m 和 n 相当于一个两维度的背包。

1.dp[i] [j]表示最多i 个 0 和 j 个 1的strs 的最大子集的大小为dp[i] [j]

2.算出前一个字符串的0 的 个数zeroNum 和 1 的个数oneNum dp[i] [j] = dp[i-zeroNum] [j-oneNum] +1

3.初始化

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];
        for(String str:strs){    //先遍历物品
            int zeroNum= 0, oneNum = 0;
            for(int i = 0;i<str.length();i++){
                if(str.charAt(i)=='0') zeroNum++;
                if(str.charAt(i)=='1') oneNum++;
            }
            for(int i = m;i>=zeroNum;i--){          //背包倒序
                for(int j = n;j>=oneNum;j--){
                    dp[i][j] = Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+1);
                }
            }
        }
        return dp[m][n];
    }
}
```

##### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

###### 518、零钱兑换II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

1.dp[j] 表示为凑齐总金额 j 的货币组合数为 dp[j]

2.dp[j] (考虑coins[i] 的组合总数) 就是所有的dp[j - coins[i]] （不考虑coins[i]）相加

3.初始化 ：dp[0] = 1

4.内层遍历从前往后

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp= new int[amount+1];
        dp[0]=1;
        for(int i = 0;i<coins.length;i++){
            for(int j = coins[i];j<=amount;j++){
                dp[j]=dp[j]+dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
}
```

###### 322、零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

1.dp[j] 表示凑成金额 j 的最少硬币个数

2.取coins[i] 时， dp[j] = dp[j - coins[i]] +1

dp[j] = min(dp[j], dp[j-coins[i]] +1);

3.初始化dp[0] = 0;

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max=amount+1;
        int[] dp=new int[max];
        Arrays.fill(dp,max);
        dp[0]=0;
        for(int i = 0;i<coins.length;i++){
            for(int j = coins[i];j<=amount;j++){
                dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);
            }
        }
        return dp[amount]==amount+1? -1 :dp[amount];

    }
}
```

##### 多重背包

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

多重背包和01背包是非常像的， 为什么和01背包像呢？

每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。



#### 打家劫舍问题

###### 198、打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

1.dp[i] 表示考虑下表 i 以内的房屋，最多可以偷窃的金额为dp[i]

2.若偷窃房屋 i ，则dp[i] = dp[i-2] +nums[i]

  若不偷房屋i，则dp[i] = dp[i-1]

dp[i] = max( dp[i-1],dp[i-2]+nums[i] )

3.初始化 dp[0] = nums[0],dp[1] = max(nums[0],nums[1])

4.遍历，从前往后

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length<=1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2 ;i<=nums.length-1;i++){
            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[nums.length-1];
    }
}
```

###### 213、打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方*所有的房屋都 围成一圈* ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额

相对上题分为两组情况，(0,nums.length-1) 和 (1,nums.length)

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        return Math.max(myRob(Arrays.copyOfRange(nums, 0, nums.length - 1)), 
                        myRob(Arrays.copyOfRange(nums, 1, nums.length)));
    }
    private int myRob(int[] nums) {
        int pre = 0, cur = 0, tmp;
        for(int num : nums) {
            tmp = cur;
            cur = Math.max(pre + num, cur);
            pre = tmp;
        }
        return cur;
    }
}
```

###### 337、打家劫舍III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210502144050.png" style="zoom:50%;" />

```java
class Solution {
    public int rob(TreeNode root) {
        int[] result = robTree(root);
        return Math.max(result[0],result[1]);
    }
    private int[] robTree(TreeNode root){
        if(root == null) return new int[]{0,0};
        int[] left =robTree(root.left);
        int[] right = robTree(root.right);
        int val1 = root.val+left[0]+right[0];
        int val2 = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        return new int[]{val2,val1};
    }
}
```

#### 买卖股票问题

###### 121、买卖股票的最佳时机（买卖一次）

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

1.dp[i] [0]表示第i天持有股票所得现金，dp[i] [1]表示为第 i 天不持有股票所得现金

2.如果第 i 天持有股票 即dp[i] [0]，

- 第i -1天就持有，那么保持现状dp[i] [0] = dp[i-1] [0]
- 第 i 天才买入，dp[i] [0] = -prices[i]

dp[i] [0] = max(dp[i-1] [0], -prices[i])

如果第 i 不持有股票，即dp[i] [1]

- 第 i-1天就不持有，那么保持现状，dp[i] [1] = dp[i-1] [1]
- 第 i-1天持有，那么，dp[i] [1] = dp[i-1] [0] +prices[i]

dp[i] [1] = max(dp[i-1] [1], dp[i-1] [0] + prices[i])

3.初始化：dp[0] [0] = -prices[0], dp[0] [1] = 0

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```

###### 122、买卖股票的最佳时机II（买卖多次）

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

1.dp[i] [0]表示第i天持有股票所得现金，dp[i] [1]表示为第 i 天不持有股票所得现金

2.如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]
- **第i天买入股票**，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1] [1] - prices[i] 

在来看看如果第i天不持有股票即dp[i] [1]的情况， 依然可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]
- 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1] [0]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i = 1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);  //唯一不同
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```

###### 123、买卖股票的最佳时机（买卖两次）

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

难点：需要标记第几次交易

1. dp[i] [j]中，i 表示第 i 天，j 为[0 - 4] 五个状态，dp[i] [j]表示第 i 天状态 j 所剩的最大现金

​    0.没有操作

​    1.第一次买入

​    2.第一次卖出

​    3.第二次买入

​    4.第二次卖出

2. 需要注意：dp[i] [1]，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票**。

   达到dp[i] [1]状态，有两个具体操作：

   - 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1] [0] - prices[i]
   - 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1] [1]

   那么dp[i] [1]究竟选 dp[i-1] [0] - prices[i]，还是dp[i - 1] [1]呢？

   一定是选最大的，所以 dp[i] [1] = max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);

   同理dp[i] [2]也有两个操作：

   - 操作一：第i天卖出股票了，那么dp[i] [2] = dp[i - 1] [1] + prices[i]
   - 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1] [2]

   所以dp[i][2] = max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])

   同理可推出剩下状态部分：

   dp[i] [3] = max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]); dp[i] [4] = max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);

3.初始化：dp[0] [0] = 0, dp[0] [1] = -prices[0], dp[0] [2] = 0, dp[0] [3] = -prices[0], dp[0] [4] = 0

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        int[][] dp = new int[prices.length][5];
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for(int i = 1;i<prices.length;i++){
            dp[i][0] = dp[i-1][0];
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4] = Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }
        return dp[prices.length-1][4];
    }
}
```

###### 188、买卖股票的最佳时机IV（买卖k次）

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

1.使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**除了0以外，偶数就是卖出，奇数就是买入**。

2.

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length == 0) return 0;
        int[][] dp = new int[prices.length][2*k+1];
        for(int j = 1;j<2*k;j+=2){
            dp[0][j] = -prices[0];
        }
        for(int i = 1;i<prices.length;i++){
            for(int j = 0;j<2*k-1;j+=2){
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.length-1][2*k];
    }
}
```

###### 309、买卖股票的最佳时机含冷冻期

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

1.dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。

- 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）

- 卖出股票状态，这里就有两种卖出股票状态

- - 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  - 状态三：今天卖出了股票

- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

j的状态为：

- 0：状态一
- 1：状态二
- 2：状态三
- 3：状态四

2.达到买入股票状态（状态一）即：dp[i] [0]，有两个具体操作：

- 操作一：前一天就是持有股票状态（状态一），dp[i] [0] = dp[i - 1] [0]

- 操作二：今天买入了，有两种情况

- - 前一天是冷冻期（状态四）
  - 前一天是保持卖出股票状态（状态二）

所以操作二取最大值，即：max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i]

那么dp[i][0] = max(dp[i - 1] [0], max(dp[i - 1] [3], dp[i - 1] [1]) - prices[i];

达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：

- 操作一：前一天就是状态二
- 操作二：前一天是冷冻期（状态四）

dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [3]);

达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：

- 操作一：昨天一定是买入股票状态（状态一），今天卖出

即：dp[i] [2] = dp[i - 1] [0] + prices[i];

达到冷冻期状态（状态四），即：dp[i] [3]，只有一个操作：

- 操作一：昨天卖出了股票（状态三）

dp[i] [3] = dp[i - 1] [2];

综上分析，递推代码如下：

```java
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i];
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][3];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i =1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][2]);
            dp[i][2] = dp[i-1][0]+prices[i];
        }
        return Math.max(dp[prices.length-1][1],dp[prices.length-1][2]);
    }
}
```

###### 714、买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i =1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);
        }
        return Math.max(dp[prices.length-1][0],dp[prices.length-1][1]);
    }
}
```

#### 子序列问题

###### 300、最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

1.dp[i] 表示为 i 之前包括 i 的最长上升子序列 数

2.位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

3.初始化dp数组为全 1

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len=nums.length;
        int[] dp=new int[len];
        Arrays.fill(dp,1);
        int result = 0;
        for(int i=0;i<len;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j])
                dp[i]=Math.max(dp[i],dp[j]+1);
            }
            result = Math.max(result,dp[i]);
        }
        return result;
    }
}
```

###### 674、最长连续递增序列

给定一个未经排序的整数数组，找到最长且 **连续**递增的子序列，并返回该序列的长度。

1.**dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。

2.如果 nums[i + 1] > nums[i]，那么以 i+1 为结尾的数组的连续递增的子序列长度 一定等于 以i为结尾的数组的连续递增的子序列长度 + 1 。

即：dp[i + 1] = dp[i] + 1;

3.初始化数组全为1

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        Arrays.fill(dp,1);
        int result = 1;
        for(int i =0;i<len-1;i++){
            if(nums[i+1]>nums[i]){
                dp[i+1] = dp[i]+1;
            }
            result = Math.max(result,dp[i+1]);
        }
        return result;
    }
}
```

###### 718、最长重复子数组

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

1.dp[i] [j]表示以下标 i-1结尾的A，和以下标j -1结尾的B的最长重复子数组长度。

2.即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1;

3.初始化为0

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length+1][nums2.length+1];
        int result = 0;
        for(int i =1;i<=nums1.length;i++){
            for(int j = 1;j<=nums2.length;j++){
                if(nums1[i-1] == nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] +1;
                }
                if(dp[i][j] >result) result = dp[i][j];
            }
        }
        return result;
    }
}
```

###### 1143、最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

1.dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i] [j]

2.如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] = dp[i - 1] [j - 1] + 1;

如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

即：dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1]);

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int[][] dp = new int[text1.length()+1][text2.length()+1];
        for(int i = 1;i<=text1.length();i++){
            for(int j = 1;j<=text2.length();j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] +1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
```



###### 583、两个字符串的删除操作

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

1.dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。

2.当word1[i-1] == word2[i-1]时dp[i] [j] = dp[i-1] [j-1];

   当word1[i-1] != word2[i-1]时有三种情况：

情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1

情况二：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1

情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i] [j] = min({dp[i - 1] [j - 1] + 2, dp[i - 1] [j] + 1, dp[i] [j - 1] + 1});

3.初始化 dp[i] [0] = i; dp[0] [j] = j;

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        for(int i = 0;i<=word1.length();i++) dp[i][0] = i;
        for(int j = 0;j<=word2.length();j++) dp[0][j] = j;
        for(int i = 1;i<=word1.length();i++){
            for(int j = 1;j<=word2.length();j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1), dp[i][j - 1] + 1);
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```

###### 72、编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

1.**dp[i] [j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]**。

2.讨论

- if (word1[i - 1] == word2[j - 1])

- - 不操作

- dp[i] [j] = dp[i] [j-1]

- if (word1[i - 1] != word2[j - 1])

- - 增
  - 删
  - 换

操作一：word1增加一个元素，使其word1[i - 1]与word2[j - 1]相同，那么就是以下标i-2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 加上一个增加元素的操作。

即 dp[i] [j] = dp[i - 1] [j] + 1;

操作二：word2添加一个元素，使其word1[i - 1]与word2[j - 1]相同，那么就是以下标i-1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个增加元素的操作。

即 dp[i] [j] = dp[i] [j - 1] + 1;

这里有同学发现了，怎么都是添加元素，删除元素去哪了。

**word2添加一个元素，相当于word1删除一个元素**，例如 word1 = "ad" ，word2 = "a"，word2添加一个元素d，也就是相当于word1删除一个元素d，操作数是一样！

操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。

即 dp[i] [j] = dp[i - 1] [j - 1] + 1;

综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i] [j] = min({dp[i - 1] [j - 1], dp[i - 1] [j], dp[i] [j - 1]}) + 1;

递归公式代码如下：

```java
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}
```

3.初始化：dp[i] [0] = i; dp[0] [j] = j;

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m=word1.length(), n=word2.length();
        int[][] dp=new int[m+1][n+1];
        for(int i=1;i<=m;i++){
            dp[i][0]=i;
        }
        for(int j=1;j<=n;j++){
            dp[0][j]=j;
        }
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=1+Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
}
```

###### 647、回文子串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

1.布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。

2.整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。

当s[i]与s[j]不相等，那没啥好说的了，dp[i] [j]一定是false。

当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况

- 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
- 情况二：下标i 与 j相差为1，例如aa，也是文子串
- 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。

以上三种情况分析完了，那么递归公式如下：

```java
if (s[i] == s[j]) {
    if (j - i <= 1) { // 情况一 和 情况二
        result++;
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
    }
}
```

result就是统计回文子串的数量。

3.初始化全为 false

4.遍历从下往上，从左往右

```java
class Solution {
    public int countSubstrings(String s) {
        boolean[][] dp = new boolean[s.length()][s.length()];
        int count = 0;
        for(int i = s.length()-1;i>=0;i--){
            for(int j = i;j<s.length();j++){
                if(s.charAt(i) == s.charAt(j)){
                    if(j-i <= 1){
                        count++;
                        dp[i][j] = true;
                    }else if(dp[i+1][j-1]){
                        count++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return count;
    }
}
```

###### 516、最长回文子序列

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

**回文子串是要连续的，回文子序列可不是连续的！** 回文子串，回文子序列都是动态规划经典题目。

1.**dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]**。

2.如果s[i] == s[j] 则 dp[i] [j] = dp[i+1] [j-1] +2;

如果s[i] != s[j] 则dp[i] [j] = max(dp[i+1] [j], dp[i] [j-1]);

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
       int len=s.length();
       if(len<2){
           return len;
       } 

       char[] s1=s.toCharArray();
       int[][] dp=new int[len][len];
       for(int i=0;i<len;i++){
           dp[i][i]=1;
       }
       for(int i=len-1;i>=0;i--){
           for(int j=i+1;j<len;j++){
               if(s1[i]==s1[j]){
                   dp[i][j]=dp[i+1][j-1]+2;
               }else{
                   dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);
               }
           }
       }
       return dp[0][len-1];
    }
}
```



## LRU缓存

##### 面试题 16.25.LRU缓存

设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。

```java
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

```java
class LRUCache {

    private LinkedList<Integer> userList;   //存储key 值，最旧的在头部，最新在尾部
    private Map<Integer,Integer> book;    
    int capacity;
    public LRUCache(int capacity) {
        userList = new LinkedList<>();
        book = new HashMap<>();
        this.capacity = capacity;
    }
    public int get(int key) {
        if(book.containsKey(key)) {
            userList.remove(new Integer(key));
            userList.addLast(key);
            return book.get(key);
        } else {
            return -1;
        }
    }
    public void put(int key,int value) {
        if(capacity == 0) {
            return;
        }
        if(!book.containsKey(key)){
            if(userList.size() >= capacity){
                book.remove(userList.removeFirst());   //同时移除usedList 和 book中最旧的
            }
            book.put(key,value);              //加入新的
            userList.addLast(key);
        } else {
            userList.remove(new Integer(key));    //g
            userList.addLast(key);
            book.put(key,value);
        }
    }
}
```



## 汉诺塔

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210505145027.png)



有三个柱子，分别为 from、buffer、to。需要将 from 上的圆盘全部移动到 to 上，并且要保证小圆盘始终在大圆盘上。

这是一个经典的递归问题，分为三步求解：

① 将 n-1 个圆盘从 from -> buffer

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210505145214.png)

② 将 1 个圆盘从 from -> to

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210505145308.png)

③ 将 n-1 个圆盘从 buffer -> to

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210505145403.png)

如果只有一个圆盘，那么只需要进行一次移动操作。

从上面的讨论可以知道，an = 2 * an-1 + 1，显然 an = 2n - 1，n 个圆盘需要移动 2n - 1 次。

```java
public class Hanoi {
    public static void move(int n, String from, String buffer, String to) {
        if (n == 1) {
            System.out.println("from " + from + " to " + to);
            return;
        }
        move(n - 1, from, to, buffer);
        move(1, from, buffer, to);
        move(n - 1, buffer, from, to);
    }

    public static void main(String[] args) {
        Hanoi.move(3, "H1", "H2", "H3");
    }
}
```



## 赫夫曼编码

1、赫夫曼树的介绍

- 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。
- 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
- 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
- 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
- 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。
- WPL最小的就是赫夫曼树。我们以3,7,8,13举例来看，建立的二叉树中，只有第二棵树的wpl值最小，也就是我们要建立的赫夫曼树。

 

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618917187530.png" style="zoom:50%;" />

 

2、为什么会需要赫夫曼树

 

通信领域中信息的处理方式---定长编码

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image002-1618917187531.png" style="zoom:67%;" />

 

 

通信领域中信息的处理方式---变长编码

![](https://gitee.com/sun-qiao321/picture/raw/master/images/变长编码.png)

 

 

通信领域中信息的处理方式---赫夫曼编码 

原始字符串：i like like like java do you like a java。 

d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 //  各个字符对应的个数。

按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值，可以知道，出现越是频繁的字符，对应的权值应该很大，那么这个字符对应的编码应该越短越好，这样可以节约字符的存储空间，提高传输的效率。

 

3、赫夫曼树的构建

构建赫夫曼树的步骤：

 

①从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树。

 

②取出根节点权值最小的两颗二叉树。

 

③组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。

 

④再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。

 

下面我们以13, 7, 8, 3, 29, 6, 1这几个数字构建一棵赫夫曼树。

首先对数据集合进行从小到大进行排序：1, 3, 6, 7, 8, 13, 29，然后取出前两个数进行合并，合并后的节点作为这两个节点的父节点。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/hfm1.png)

 

 

经过第一次的合并，我们得到的序列是：4,6,7,8,13,29，下面在第一次合并的基础上，再次对序列进行排序，然后取出最前面的两个数进行合并并且建立新的节点，作为父节点。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/hfm2.png)

 

 

经过第二次合并，我们的序列变为：7,8,10,13,29，（已排序），经过多轮次的合并后，我们可以得到一棵赫夫曼树。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/hfm3.png)

 

3、字符传输案例

带传输的字符串：i like like like java do you like a java   

统计各个字符出现的次数：d:1， y:1， u:1 ，j:2 ， v:2， o:2， l:4 ， k:4 ，e:4， i:5 ， a:5 ，空格 :9 

按照上面字符出现的次数构建一颗赫夫曼树, 字符出现的次数作为权值

![](https://gitee.com/sun-qiao321/picture/raw/master/images/hfm4.png)

根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ，

编码如下: o: 1000  u: 10010  d: 100110  y: 100111  i: 101 a : 110   k: 1110   e: 1111    j: 0000    v: 0001 l: 001      : 01

按照上面的赫夫曼编码，我们的"i like like like java do you like a java"  字符串对应的编码为 (注意这里我们使用的无损压缩) 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 ，长度为  133。

长度为 ： 133 说明: 原来长度是  359 , 压缩了  (359-133) / 359 = 62.9% 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 赫夫曼编码是无损处理方案。

```java
public class Huffman {

    private class Node implements Comparable<Node> {
        char ch;
        int freq;
        boolean isLeaf;
        Node left, right;

        public Node(char ch, int freq) {
            this.ch = ch;
            this.freq = freq;
            isLeaf = true;
        }

        public Node(Node left, Node right, int freq) {
            this.left = left;
            this.right = right;
            this.freq = freq;
            isLeaf = false;
        }

        @Override
        public int compareTo(Node o) {
            return this.freq - o.freq;
        }
    }

    public Map<Character, String> encode(Map<Character, Integer> frequencyForChar) {
        PriorityQueue<Node> priorityQueue = new PriorityQueue<>();
        for (Character c : frequencyForChar.keySet()) {
            priorityQueue.add(new Node(c, frequencyForChar.get(c)));
        }
        while (priorityQueue.size() != 1) {
            Node node1 = priorityQueue.poll();
            Node node2 = priorityQueue.poll();
            priorityQueue.add(new Node(node1, node2, node1.freq + node2.freq));
        }
        return encode(priorityQueue.poll());
    }

    private Map<Character, String> encode(Node root) {
        Map<Character, String> encodingForChar = new HashMap<>();
        encode(root, "", encodingForChar);
        return encodingForChar;
    }

    private void encode(Node node, String encoding, Map<Character, String> encodingForChar) {
        if (node.isLeaf) {
            encodingForChar.put(node.ch, encoding);
            return;
        }
        encode(node.left, encoding + '0', encodingForChar);
        encode(node.right, encoding + '1', encodingForChar);
    }
}
```



##  二叉树的非递归遍历

要求：O（1）空间复杂度，即只能使用常数空间；

   不能破坏二叉树的形状

 

Morris Traversal方法可以做到这两点，与前两种方法的不同在于该方法只需要O(1)空间，而且同样可以在O(n)时间内完成。

Morris只提供了中序遍历的方法，在中序遍历的基础上稍加修改可以实现前序，而后续就要再费点心思了。所以先从中序开始介绍。

 

中序遍历步骤：

1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。（前驱节点即“当前节点左子树的最右叶子节点”，此时最右节点的右孩子有两种情况，一种是指向当前节点，一种是为空）

a）如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

b）如果前驱节点的右孩子为当前节点，将它的右孩子设置为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。

1. 重复以上1、2直到当前节点为空

 

图示：下图为每一步迭代的结果（从左至右，从上至下），cur表示当前节点，深色节点表示已输出。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/中序非递归遍历.jpg)

 

前序遍历步骤：

前序遍历与中序遍历相似，代码上只有一行不同，不同就在于输出的顺序。

步骤：

1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。
             a)     如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。输出当前节点（在这里输出，这是与中序遍历唯一一点不同）。当前节点更新为当前节点的左孩子。
             b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。当前节点更新为当前节点的右孩子。
3. 重复以上1、2直到当前节点为空。

图示：

![](https://gitee.com/sun-qiao321/picture/raw/master/images/前序非递归遍历.jpg)

 

后序遍历步骤：

后续遍历稍显复杂，需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。

步骤：

当前节点设置为临时节点dump。

1. 如果当前节点的左孩子为空，则将其右孩子作为当前节点。
2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。
             a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。
             b)     如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。倒序输出从当前节点的左孩子到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右孩子。
3. 重复以上1、2直到当前节点为空。

 

![](https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image003-1618917281898.png)





## 并查集

#### 问题描述

并查集是一种树型的数据结构，用于处理一些不相交集合的合并以及查询问题。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504214306.png" style="zoom:67%;" />

应用场景：亲戚问题

**题目描述**
规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。
**输入格式**
第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。
以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。
接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。
**输出格式**
P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。

#### 方法定义

|              方法               |           描述            |
| :-----------------------------: | :-----------------------: |
|            UF(int N)            | 构造一个大小为 N 的并查集 |
|    void union(int p, int q)     |     连接 p 和 q 节点      |
|         int find(int p)         | 查找 p 所在的连通分量编号 |
| boolean connected(int p, int q) | 判断 p 和 q 节点是否连通  |

```java
public abstract class UF {

    protected int[] id;

    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public abstract int find(int p);

    public abstract void union(int p, int q);
}
```

#### Quick Find

可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。

需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。

但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504215854.png" style="zoom:67%;" />

```java
public class QuickFindUF extends UF {

    public QuickFindUF(int N) {
        super(N);
    }


    @Override
    public int find(int p) {
        return id[p];
    }


    @Override
    public void union(int p, int q) {
        int pID = find(p);
        int qID = find(q);

        if (pID == qID) {
            return;
        }

        for (int i = 0; i < id.length; i++) {
            if (id[i] == pID) {
                id[i] = qID;
            }
        }
    }
}
```

#### Quick Union

可以快速进行 union 操作，只需要修改一个节点的 id 值即可。

但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。

这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504220352.png" style="zoom:67%;" />



```java
public class QuickUnionUF extends UF {

    public QuickUnionUF(int N) {
        super(N);
    }


    @Override
    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }


    @Override
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot != qRoot) {
            id[pRoot] = qRoot;
        }
    }
}
```

#### 加权 Quick Union

为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。

理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504221206.png" style="zoom:67%;" />

```java
public class WeightedQuickUnionUF extends UF {

    // 保存节点的数量信息
    private int[] sz;


    public WeightedQuickUnionUF(int N) {
        super(N);
        this.sz = new int[N];
        for (int i = 0; i < N; i++) {
            this.sz[i] = 1;
        }
    }


    @Override
    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }


    @Override
    public void union(int p, int q) {

        int i = find(p);
        int j = find(q);

        if (i == j) return;

        if (sz[i] < sz[j]) {
            id[i] = j;
            sz[j] += sz[i];
        } else {
            id[j] = i;
            sz[i] += sz[j];
        }
    }
}
```

#### 路径压缩的加权Quic Union

在检查节点的同时将它们直接链接到根节点，只需要修改find。

```java
    public int find(int p) {
        if(p == id[p])
            return p;
        else {
            id[p] = find(id[p]);
            return id[p];
        }
    }
```

#### 比较

|            算法            |   union    |    find    |
| :------------------------: | :--------: | :--------: |
|         Quick Find         |     N      |     1      |
|        Quick Union         |    树高    |    树高    |
|      加权 Quick Union      |    logN    |    logN    |
| 路径压缩的加权 Quick Union | 非常接近 1 | 非常接近 1 |

#### LeetCode

###### 130、被围绕的区域

**DFS**

从边界上的 O 开始搜索，搜索过程中将O替换为  # 。搜索结束之后，遇到O替换成X，遇到# 替换成 O。

```java
class Solution {
    public void solve(char[][] board) {
        if(board == null || board.length == 0) return;
        int m = board.length;
        int n = board[0].length;
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                boolean isEage = i==0 ||i==m-1||j==0||j==n-1;
                if(isEage && board[i][j] =='O'){
                    dfs(board,i,j);
                }
            }
        }

        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                if(board[i][j] == 'O') board[i][j] ='X';
                if(board[i][j] == '#') board[i][j] ='O';
            }
        }
    }
    public void dfs(char[][] board,int r,int c){
        if(r<0 ||r>=board.length||c<0||c>=board[0].length) return;
        if(board[r][c] != 'O') return;
        board[r][c] = '#';
        dfs(board,r-1,c);
        dfs(board,r+1,c);
        dfs(board,r,c-1);
        dfs(board,r,c+1);
    }
}
```

**并查集**

```java
class Solution {

    //并查集类
    class UF{
        private int[] ID;
        private int[] treeSize;
        public UF(int N){
            ID = new int[N];
            treeSize = new int[N];
            for(int i = 0; i < N; i++){
                ID[i] = i;
                treeSize[i] = 1;
            }
        }

        public int find(int p) {
            if(p == ID[p])
                return p;
            else {
                ID[p] = find(ID[p]);
                return ID[p];
            }
        }

        public boolean connected(int p, int q){
            return find(p) == find(q);
        }

        public void union(int p, int q){
            int i = find(p);
            int j = find(q);
            if(i == j) return;
            if(treeSize[i] < treeSize[j]){
                ID[i] = j;
                treeSize[j] += treeSize[i];
            }else{
                ID[j] = i;
                treeSize[i] += treeSize[j];
            }
        }    
    }

    //将二维坐标转化为一维坐标, 便于并查集使用
    //ｘ为二维数组的一维索引，　ｙ为二维数组的二维索引
    private int flatternTowDim(int x, int y, int width){
        return x * width + y;
    }

    public void solve(char[][] board) {
        if(board.length == 0) return;
        int len = board.length;
        int width = board[0].length;
        int boardSize = len * width;
        UF uf = new UF(boardSize+1);
        //添加一个虚拟节点，所有位于边界的Ｏ节点均与该虚拟节点相连接
        int i, j;
        for(i = 0; i < board.length; i++){
            for(j = 0; j < board[0].length; j++){
                if((i == 0 || i == board.length-1 || j == 0 || j == board[0].length-1) && board[i][j]=='O')
                    uf.union(flatternTowDim(i, j, width), boardSize);
            }
        }

        //遍历搜索相邻的Ｏ，添加到并查集中
        for(i = 0; i < board.length; i++){
            for(j = 0;j < board[0].length; j++){
                if(board[i][j] == 'O'){
                    //将当前Ｏ点与其上下左右四个方向的Ｏ点相连接
                    if(i-1 >=0 && board[i-1][j] == 'O')
                        uf.union(flatternTowDim(i-1, j, width), flatternTowDim(i, j, width));
                    if(i+1 < board.length && board[i+1][j] == 'O')
                        uf.union(flatternTowDim(i+1, j, width), flatternTowDim(i, j, width));
                    if(j-1 >= 0 && board[i][j-1] == 'O')
                        uf.union(flatternTowDim(i, j-1, width), flatternTowDim(i, j, width));
                    if(j+1 <= board[0].length && board[i][j] == 'O')
                        uf.union(flatternTowDim(i, j+1, width), flatternTowDim(i, j, width));
                }
            }
        }

        //将所有与边界节点不相连的＇Ｏ＇点替换为＇Ｘ＇
        for(i = 0; i < board.length; i++){
            for(j = 0; j < board[0].length; j++){
                if(board[i][j] == 'O' && !uf.connected(flatternTowDim(i, j, width), boardSize))
                    board[i][j] = 'X';
            }
        }
    }
}
```



###### 200、岛屿数量

**DFS**

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0;i<grid.length;i++){
            for(int j = 0;j<grid[0].length;j++){
                if(grid[i][j] == '1') {
                    count++;
                    dfs(grid,i,j);
                }
            }
        }
        return count;
    }
    private void dfs(char[][] grid,int r, int c){
        if(r<0|| r>= grid.length || c<0 || c>=grid[0].length) return;
        if(grid[r][c] !='1') return;
         grid[r][c] = '2';
         dfs(grid,r-1,c);
         dfs(grid,r+1,c);
         dfs(grid,r,c-1);
         dfs(grid,r,c+1);
    }
}
```

**BFS**

**Union-Find**



###### 547、省份数量

给一个 n × n的矩阵 isConnected，其中isConnected[i] [j] = 1表示第i 个城市和第 j 个城市直接相连，而 isConnected[i] [j] = 0，表示两者不直接相连。返回矩阵中省份数量。

并查集解法，使用count计数，若有相连，则count--。

```java
class Solution {
    class UF {
        private int[] id;
        private int[] treeSize;
        private int count;
        public UF(int N){
            id = new int[N];
            treeSize = new int[N];
            count = N;
            for(int i = 0;i<N;i++){
                id[i] = i;
                treeSize[i] = 1;
            }
        }
        public int find(int p){
            if(p == id[p]) return p;
            else{
                id[p] = find(id[p]);
                return id[p];
            }
        }
        public boolean connected(int p,int q){
            return find(p) == find(q);
        }
        public void union(int p,int q){
            int i = find(p);
            int j = find(q);
            if(i == j) return;
            if(treeSize[i] < treeSize[j]){
                id[i] = j;
                treeSize[j] += treeSize[i];
            }else{
                id[j] = i;
                treeSize[i] += treeSize[j];
            }
            count--;
        }
        public int getCount(){
            return count;
        }
    }
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        if(n == 0) return 0;
        UF uf = new UF(n);
        for(int i = 0;i<n;i++){
            for(int j = i;j<n;j++){
                if(isConnected[i][j] == 1){
                    uf.union(i,j);
                }
            }
        }
        return uf.getCount();
    }
}
```

###### 721、账户合并

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210505104456.png" style="zoom:67%;" />

```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        // 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]
        // 格式：<邮箱，账户id>
        Map<String, Integer> emailToId = new HashMap<>();
        int n = accounts.size();//id个数
        UnionFind myUnion = new UnionFind(n);
        for(int i = 0; i < n; i++){
            int num = accounts.get(i).size();
            for(int j = 1; j < num; j++){
                String curEmail = accounts.get(i).get(j);
                //当前邮箱没有出现过
                if(!emailToId.containsKey(curEmail)){
                    emailToId.put(curEmail, i);
                }else{//当前邮箱已经出现过，那么代表这两个用户是同一个
                    myUnion.union(i, emailToId.get(curEmail));
                }
            }
        }
        //进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id
        // 作用： 存储每个账户下的邮箱
        // 格式： <账户id, 邮箱列表> >
        // 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖
        Map<Integer, List<String>> idToEmails = new HashMap<>();
        //将同一个连通域内的邮箱对应到同一个id【也就是第一次出现的id，比如4、5在同一个连通域，那么这个连通域对应的id就是4】
        for(Map.Entry<String, Integer> entry : emailToId.entrySet()){
            int id = myUnion.find(entry.getValue());
            List<String> emails = idToEmails.getOrDefault(id, new ArrayList<>());
            emails.add(entry.getKey());
            idToEmails.put(id,emails);
        }
        //经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了
        List<List<String>> res = new ArrayList<>();
        for(Map.Entry<Integer, List<String>> entry : idToEmails.entrySet()){
            List<String> emails = entry.getValue();
            Collections.sort(emails);
            List<String> tmp = new ArrayList<>();
            tmp.add(accounts.get(entry.getKey()).get(0));//先添加用户名
            tmp.addAll(emails);
            res.add(tmp);
        }
        return res;
    }
}

class UnionFind {
    int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public void union(int index1, int index2) {
        parent[find(index2)] = find(index1);
    }

    public int find(int index) {
        if (parent[index] != index) {
            parent[index] = find(parent[index]);
        }
        return parent[index];
    }
}

```



## 加密算法

#### 单项散列加密

又称hash函数，是指通过对任意长的信息，进行散列计算，得到固定长度的输出结果，一般用于生成密钥加密、消息摘要等。

常用的散列算法：MD5 和 SHA

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210420203708534.png)

```java
public static void main(String[] args) {
  String text = "1024lab";
  text = SmartDigestUtil.md5Hex(text);
  System.out.println("MD5 ->" + text);

  text = SmartDigestUtil.sha1Hex(text);
  System.out.println("SHA1 ->" + text);
}

输出结果：
MD5 -> 42d2d52631590edf953eab18f0685068
SHA1 -> a3f61863926840b46935c306c7c5365447d95b9a
```

##### 单项散列算法特性（所追求的安全）

- 定长输出

无论原始数据多长，散列值都是短且固定的

- 能够快速计算出散列值

所花费的时间必须要短，如果不能在现实的时间内完成计算就没有意义了。

- 消息不同散列值也不同

抗碰撞性（collision resistance）

雪崩效应：输入的微小改变，将会引起结果的巨大不同。 

弱碰撞性：要找到和该条消息具有相同的散列值的另外一条消息是非常困难的。 

强碰撞性：要找到散列值相同的两条不同的消息是非常困难的。

- 具备单向性

这个散列计算过程是单向，意味着无法通过散列值反算出消息。

##### 单向散列算法会存在重复的结果吗？

> 正如前面所说：要找到散列值相同的两条不同的消息是非常困难，但不代表不会重复，因为hash的原理就是抽样，取信息的特征，只要有足够多的数据，肯定会产生相同的结果。
>
> 但这其实并不影响单向散列算法的使用。因为单向散列的的作用重点在于：“签名”（Signature）- 验证数据的一致性，而非加密。

##### 真的无法通过散列值推算出原文吗？

> 正如上文提到的散列算法是提取信息的特征，压缩映射，换而言之输出的散列值是有损的，是不可能根据残缺的数据反算出原始信息的。 
>
> 但这并不意味着就无懈可击了，在实际情况中，攻击者可以通过穷举，彩虹表，进行猜测式的暴力破解，推算出可能的原文。
>
>
> 例如，很多开发中使用md5计算存储用户密码的例子，因为密码大多长度在十位左右，攻击者可以以很低的成本计算所有密码组合的散列值，就可以得到可能的原始密码。
>
>
> 所以为了加强单向散列计算的安全性，还会给散列算法加点盐（salt），将消息和盐混合后计算其散列值。
> 此时 salt 就相当于密钥，如果有人想要暴力破解，就必须还要得到 salt 密钥才行。

##### 日常使用场景

###### 校验文件是否被篡改

如今软件下载网站为了避免用户下载到被不法分子恶意修改、植入病毒后的文件，一般都会在提供文件的同时，提供文件计算后的散列值。

用户下载之后，借助提供的散列算法工具，计算散列值，与官方网站公布的散列值进行对比，从而确保自己下载的文件是完整、一致的，避免信息泄露或财产损失。

还有常用的版本管理工具 GIT、SVN，检测文件是否修改过，也是用到了散列算法MD5。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/3c62357bf58de312a293333680f53ea7.png" style="zoom:50%;" />

###### 口令加密，防止直接看到明文

2011年12月CSDN密码泄露事故中，大家发现CSDN数据库中的用户密码居然是明文保存，导致无数用户密码被挂黑市交易，引起众人的无语吐槽。

现在很多系统都是在数据库存储用户密码的MD5值，UNIX系统中用户的密码也是以MD5（或其它类似的算法）经加密后存储在文件系统中。

这样就算不法分子得到用户密码的MD5值，也无法知道用户的密码(当然你现在也知道了，没有绝对的安全)。避免了用户的密码被明文暴露，而且还在一定程度上增加了密码被破解的难度。

此外还有开发中各类API接口调用的签名校验、伪随机数生成，生成一次性的口令等等。

###### 数字签名

其实与前面的校验文件是否被篡改原理是一样的，但这里的场景用途不同。

例如A写了一个文件，只需要对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。

这就是所谓的“数字签名”，数字签名提供不可伪装性（不是别人写的），也不可抵赖（否认是自己的）



#### 对称加密算法

对称加密是指加密和解密使用的密钥，是同一个密钥。

发送方A使用双方约定的密钥，对信息进行对称加密，将密文发送给B。

接收方B使用相同的密钥，对密文进行解密，得到信息原文。

常见算法：DES/3DES/AES/RC等

**优点：**

加密效率高，系统运算开销小，适合对大量数据加密。

**缺点：**

如果要解密就得让对方知道密钥，远程通信的情况下如何安全的交换保存密钥是个难题。如果密钥丢失，那么所有的加密信息也就没有秘密可言了，所以保证其安全性就是需要保证密钥的安全。

#### 非对称加密

非对称加密和解密使用的密钥不是同一个密钥。

一个对外界公开，称为publickey【公钥】

另一个只有所有者知道，称为privatekey【私钥】

公钥与私钥是一对

用公钥加密的信息，只有使用私钥才能解开，

反之，用私钥加密的信息只有公钥才能解开。

常见算法：RSA、Elgamal、背包算法、Rabin等。

**优点：**保密性好，消除用户交换密钥的需要

**缺点：**相对于对称加密效率比较慢

#### 混合加密

混合使用对称和非对称加密技术

- A先使用 RSA(非对称加密) 生成自己的公钥和私钥，然后把公钥以明文的方式发送给B。
- B拿到公钥后，对AES(对称加密) 的秘钥进行加密然后返回给A
- A收到对称加密后的AES秘钥后，就可以直接使用自己的私钥解密获得AES的秘钥明文。
- 之后两者的通信就可以使用AES(对称加密)来实现敏感信息的加密。

即解决了AES（对称加密）密钥的传输问题，又解决了RSA（非对称加密）算法效率不高的问题。

## 数据的二进制

https://mp.weixin.qq.com/s/evMy7Jz-3nRmr887DfHkjw

整型数都是用补码表示。首位表示符号位，正数是0 ，负数是 1。正数直接二进制表示，负数则需要取反加一。

使用补码表示时，对于负数的加减法才不需要处理。

