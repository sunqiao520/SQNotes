 ## 计算机网络概述

[TOC]

 [JavaGuide](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/计算机网络知识总结.md) 

 [CS-Notes](http://www.cyc2018.xyz/计算机基础/网络基础/计算机网络 - 目录.html)

 ### 一、基本术语

 1. **结点** （node）：网络中的结点可以是计算机，集线器，交换机或路由器等。
  2. **链路**（link）：从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。
  3. **主机**（host）：连接在因特网上的计算机。
  4. **ISP**（Internet Service Provider）：因特网服务提供者（提供商）。
  5. **IXP**（Internet eXchange Point）：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。
  6. **RFC**(Request For Comments) ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。
  7. **广域网** WAN（Wide Area Network） ：任务是通过长距离运送主机发送的数据。
  8. **城域网** MAN（Metropolitan Area Network）：用来将多个局域网进行互连。
  9. **局域网** LAN（Local Area Network） ： 学校或企业大多拥有多个互连的局域网。

10.**个人区域网** PAN（Personal Area Network） ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。

11.**分组**（packet ） ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。

12.**存储转发**（store and forward） ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。

13.**带宽**（bandwidth）：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为      b/s。

14.**吞吐量**（throughput） ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。

  

 ### 二、网络的网络

   网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。

###  三、计算机网络体系结构

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210416162437050.png" style="zoom:80%;" />

网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。

 五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。

 <img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210422093728.png" style="zoom:67%;" />

 ### 四、各层的作用

 **应用层**(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是*应用进程（进程：主机中正在运行的程序）间的通信和交互的规则*。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。

> 应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的，就类似于，我们寄快递时，只需要把包裹交给快递员，由他负责运输，我们不需要关心快递是如何运输的。

 

**传输层**(transport layer)的主要任务就是负责向两台主机*进程之间的通信提供通用的数据传输服务*。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

 

 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。**网络层**的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。



 **数据链路层**(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

  

 在物理层上所传送的数据单位是比特。

 **物理层**(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。



## 应用层（Appiication Layer）

 《图解HTTP》

 [硬核！30  张图解 HTTP 常见的面试题](https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw)

 [如果面试再问GET和POST区别，就把这篇甩给他](https://mp.weixin.qq.com/s/BraxnIUJF4JGtIep0YiovA)

### 一、基本术语

1.**域名系统（DNS）** ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，[www.baidu.com](http://www.baidu.com/)) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。

2.**文件传输协议（FTP）** ：FTP 是 File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念："下载"（Download）和"上传"（Upload）。 "下载"文件就是从远程主机拷贝文件至自己的计算机上；"上传"文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。

3.**简单文件传输协议（TFTP）** ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。

4.**远程终端协议（TELNET）** ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。

5.**万维网（WWW）** ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，"环球网"等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。

**万维网的大致工作工程：**

[<img src="https://camo.githubusercontent.com/af1e5c61f648e0a1658976a0303f2fd1a3c494e36b2622e989b3fe8ed61fbecd/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f37333566353535303165383138393861613631623830333266376462636237332e706e67" alt="万维网的大致工作工程" style="zoom:67%;" />](https://camo.githubusercontent.com/af1e5c61f648e0a1658976a0303f2fd1a3c494e36b2622e989b3fe8ed61fbecd/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f37333566353535303165383138393861613631623830333266376462636237332e706e67)

6.**统一资源定位符（URL）** ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

7.**超文本传输协议（HTTP）** ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。

HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：

[<img src="https://camo.githubusercontent.com/11b0b0048afa084b1c8f1c70675a9e862a70783b8da643dcfddd2b846dcbbbd3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f62323733656665663566323338386532363431343133353637326230303239352e706e67" alt="img" style="zoom: 50%;" />](https://camo.githubusercontent.com/11b0b0048afa084b1c8f1c70675a9e862a70783b8da643dcfddd2b846dcbbbd3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f62323733656665663566323338386532363431343133353637326230303239352e706e67)

8.**代理服务器（Proxy Server）** ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。

9.**简单邮件传输协议(SMTP)** : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。

10.**搜索引擎** :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。

11.**垂直搜索引擎** ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。

12.**全文索引** :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。

13.**目录索引** ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。

### URI与URL的区别

**URI：**Uniform Resource Identifier  统一资源标识符，是一个用于标识互联网资源名称的字符串。
**URL：**Uniform Resource Location  统一资源定位符

HTTP 使用 URL来定位资源，它是 URI的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。

### HTTP的优点与缺点

优点

- 简单
- 灵活和易于扩展
- 应用广泛和跨平台

缺点

- 通常使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

#### 方法：

**GET：** 获取资源

**HEAD**：获得报文首部。与GET类似，只是不返回报文主体部分，用于确认URL的有效性及资源更新的日期时间等。

**POST:** 传输实体主体 

**PUT：** 上传文件

**PATCH：**对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。

**DELETE：** 与PUT相反，用于删除文件

**OPTION:**  查询支持的方法。查询指定URL能够支持的方法。返回`Allow: GET,POST,HEAD,OPTIONS`这样的内容。

**CONNECT：**要求与代理服务器通信时建立隧道

#### 常见状态码

**1XX：**信息性状态码，接受的请求正在处理

**2XX：**成功状态码，请求正常处理完毕

200 OK ；  

204 No Content（返回的报文中不含实体主体部分） ；  

206 Partial Content （客户端进行了范围请求，服务器成功执行）

**3XX：**重定向状态码，需要进行附加操作以完成请求

301 Moved Permanently （永久性重定向，表明请求的资源已经分配了新的URI）

302 Found （临时性重定向）

303 See Other 

304 Not Modified

307 Temporary Redirect 

**4XX**：客户端错误状态码，服务器无法处理请求

400 Bad Request 请求报文中存在错误

401 Unauthorized 发送的请求需要通过HTTP认证

403 Forbidden 该请求被服务器拒绝

404 Not Found 无法找到该请求资源

**5XX**：服务器错误状态码，服务器处理请求出错

500 Internal Server Error 服务端在执行请求时发生了错误

503 Service Unavailable  服务器处于超负荷或正在进行停机维护，现在无法提供请求

 

#### COOKIE和SESSION的区别？

**cookie**

为了保留无状态协议这个特征的同时，又想解决类似自动登录的问题而引入了COOKIE。

COOKIE技术通过在请求和响应报文中写入COOKIE信息来控制客户端状态。服务端的响应报文中会有字段通知客户端保存COOKIE，下次再往该服务端发送请求时会自动加上COOKIE值。服务端会根据该COOKIE值去获取之前的记录。

**session**

为了保存用户状态，比如淘宝的购物车。session是保存在服务端的，可以利用内存、数据库、文件都有。

**区别**

cookie 存在本地，而session存在服务端。（但session id 仍存在cookie中）

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。



### HTTP/1.0比较HTTP/1.1、HTTP/2  HTTP/3

HTTP1.1对HTTP1.0的改进：

①长连接

早期的HTTP/1.0每发起一个请求，都要新建一次TCP连接，增加了通信开销。

HTTP/1.1使用持久连接的通信方式。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/长连接.png" style="zoom:67%;" />

②管道网络传输

HTTP/1.1的长连接为管道（pipeline）网络传输成为可能。即可以在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不必等它回来，就可以发第二个请求出去，减少整体的响应时间。

**HTTP/1.1的性能瓶颈**

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是**队头阻塞**；

- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

**Http/2相比Http/1.1性能上的改进？**

- 头部压缩

HTTP/2会压缩头部（Header）。如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。

**HPACK算法**：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，就提高速度了。

- 二进制格式

HTTP / 1.1使用纯文本形式的报文，这通常在网络上效率较低。而HTTP / 2是**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame)：头信息帧和数据帧。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504151358.png" style="zoom:67%;" />

- 数据流

HTTP/2数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对这些数据包做标记，指出它属于哪个回应。

每个请求或回应的所有数据包，称为一个数据流（**Stream**）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。

- HTTP / 2是多路复用的

在HTTP / 1.1中，任何时候都只能在TCP连接上处理一个请求。浏览器通常在四到八个连接之间打开，但是大型或慢速资产可能导致其他文件的下载延迟。而HTTP / 2允许在同一（单个）连接上并发多个请求和响应消息。

- 服务器推送

HTTP/2还在一定程度上改善了传统的请求-应答工作模式，服务器不再是被动的响应，也可以主动向客户端发送消息。

**HTTP/2 的缺陷，HTTP/3的优化？**

HTTP/2主要的问题在于，多个HTTP请求在复用一个TCP连接，下层的TCP协议是不知道有多少个HTTP请求的。所以一旦发生了丢包现象，就会触发TCP的重传机制，这样在一个TCP连接中的所有的HTTP请求都必须等待这个丢了的包被重传回来。

- HTTP/1.1中的管道（pipeline) 传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
- HTTP/2多个请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的HTTP请求。

这都是基于TCP传输层，所以HTTP/3 把 HTTP 下层的TCP协议改成了UDP。UDP发生是不管顺序，也不管丢包的，所以不会出现HTTP/1.1的队头阻塞和HTTP/2的一个丢包全部重传问题。
大家都知道UDP是不可靠传输的，但基于UDP的QUIC协议可以实现类似TCP的可靠性传输。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504153107.png" style="zoom:67%;" />





### HTTPS

HTTPS=HTTP+加密+认证+完整性保护

两者的区别：

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- HTTP 的端口号是  80，HTTPS 的端口号是 443。
- HTTPS 协议需要向  CA（证书权威机构）申请数字证书，来保证服务器的身份是可信

 <img src="https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210420152059719.png" style="zoom:50%;" />

**HTTP的安全风险：**

**窃听风险、篡改风险、冒充风险**

HTTPS通过使用`混合加密`的方式进行信息加密，解决了窃听的风险；

`摘要算法`的方式来实现完整性，它能够为数据生成独一无二的指纹，指纹用于检验数据的完整性，解决了篡改的风险；

将服务器公钥放到`数字证书`中，解决了冒充的风险

##### 加密

**1.对称密钥加密**

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。

**2.非对称密钥加密**

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

**3.HTTPS采用加密方式**

上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。

##### 认证

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210504145525.png" style="zoom:67%;" />

##### 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

**HTTPS的缺点：**

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

### HTTPS为什么安全

HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

HTTPS相比HTTP的优势：

- 数据完整性：内容传输经过完整性校验
- 数据隐私性：内容经过对称加密，每一个连接生成一个唯一的加密密钥
- 身份认证：第三方无法伪造服务端（客户端）身份

### HTTPS是如何建立连接的，其间交互了什么？

SSL/TLS协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产会话密钥。
- 双方采用会话密钥进行加密通信。



### GET和POST的区别

- 含义

GET方法的含义是从服务器获取资源。这个资源可以是静态的文本、页面，图片视频等。

POST向指定的资源提交数据，数据在报文body里。

- 参数

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

- 安全

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。

安全的方法除了 GET 之外还有：HEAD、OPTIONS。

不安全的方法除了 POST 之外还有 PUT、DELETE。

- 幂等。

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

所有的安全方法也都是幂等的。

在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903285126.png" style="zoom: 67%;" />

【GET与POST区别】

GET用于请求数据，POST用于发送数据。

1.GET发一次，POST发两次

​	GET方式的请求，浏览器会把http header和data一并发送出去；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

2.GET请求的数据会**暴露在URL内**，而POST数据放在**HTTP包的包体中**

3.GET长度受限于URL的长度，而POST的长度在HTTP协议中没有进行限制

4.对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

### 从URL输入到浏览器出现页面，中间发生了什么？

**1.解析输入的URL**

浏览器的第一步工作就是要对 URL 进行解析，从而生成发送给 Web 服务器的请求信息。对URL 进行解析之后，浏览器确定了Web 服务器和文件名，接下来根据这些信息生成 HTTP 请求消息。

**2.DNS解析**

首先询问DNS缓存（包括浏览器缓存和本地缓存），没有就去DNS服务器获取URL对应的IP地址。如果请求协议是HTTPS，那么还需要建立SSL 连接。

**3.TCP通信**

三次握手的过程，然后发送HTTP请求

**4.数据处理**

服务器收到请求后进行处理，返回报文及状态码

**5.浏览器渲染**

...

**6.TCP断开**

四次挥手

### DNS

DNS同时使用TCP和UDP ，但主要是UDP。客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。

DNS查询超过512字节时，超过UDP的最大限制，使用TCP重发；区域传送（辅助DNS向主DNS查询是否有数据变动）将使用TCP。



### 文件断点续传如何实现？

range协议。它是的客户端在一次请求中可以只下载完整文件的某个部分。 1. 只需要另外记录已下载的偏移量，则可实现断点续传   2.可以开启多线程同时下载，再组合成一个完整文件。

## 传输层（Transport Layer）

参考资料及链接：

[探究：一个数据包在网络中到底是怎么游走的？](https://mp.weixin.qq.com/s/07zloKKMUl-RHN6tWqZIJQ)

[硬不硬你说了算！全图解被问千百遍的TCP三次握手和四次挥手面试题](https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg)

[计网 TCP/UDP 部分高频面试题大集合](https://mp.weixin.qq.com/s/SZ8XcOzZCVJG_P1_O4OtWQ)

### 一、基本术语

1.**进程**（process） ：指计算机中正在运行的程序实体。

2.**应用进程互相通信** ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。

3.**传输层的复用与分用** ：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。

4.**TCP**（Transmission     Control Protocol） ：传输控制协议。

5.**UDP**（User Datagram     Protocol） ：用户数据报协议。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903310089.png" style="zoom:50%;" />

6.**端口**（port） ：端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如 MSN 和 QQ     的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。

7.**停止等待协议**（stop-and-wait） ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。

8.**流量控制** :     就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。

9.**拥塞控制** ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。



### 介绍TCP/IP协议？

TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。

### 介绍TCP？TCP连接的本质？

传输控制协议（Transmission Control Protocol）是一种**面向连接的、可靠的、基于字节流**的传输层通信协议。

面向连接的服务（connection-oriented service）就是通信双方在通信时,要事先建立一条通信线路,其过程有建立连接、使用连接和释放连接三个过程。

“连接”：这个连接并不是真正意义上的连接，是为了告知彼此第一个发送字节的初始序列号，建立连接后就需要以这个序号为起点进行编号，来确认是否成功到达。

“字节流”：字节流是指传输过程中，传输数据的最基本单位是字节的流，一个不包含边界数据的连续流。

使用场景：当对网络通信质量有要求时，比如：整个数据要准确无误的传递给对方，比如HTTP,HTTPS,FTP等传输文件的协议，POP,SMTP等邮件的传输协议

### TCP的头部格式

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903424992.png" style="zoom:67%;" />

源端口和目的端口字段（16位）在TCP头部，告诉TCP协议应该将报文发给哪个进程。

序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决不丢包的问题。**

**首部**长度给出首部中32bit的数目

**控制位：**

- *URG*：紧急指针有效

- *ACK*：该位为 1 时，「确认应答」的字段变为有效，TCP     规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。

- *PSH*：发送方使用该标志通知接收方将收到的数据全部提交给接收进程

- *RST*：该位为 1 时，表示     TCP 连接中出现异常必须强制断开连接。

- *SYN：该位为 1 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。

- *FIN*：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为     1 的 TCP 段。

  **窗口大小** 起始于确认序号指明的值，这个值是接收端正期望接收的字节。16bit所以窗口最大为65535字节。

  **检验和** 覆盖所有报文段

  **紧急指针** 是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号，用于发送紧急数据。



### 介绍UDP？

用户数据报协议(User Datagram Protocol)，可以将UDP协议看作IP协议暴露在传输层的一个接口，区别在于在IP协议的基础上另外实现了端口号、长度、校验和。

"无连接"：不需要预先建立起一个联络两个通信节点的连接、没有连接和断开的过程。数据包访问到网络节点时，根据路由信息自主的传播。但无法保证次序，并且可能丢失。

如何一对多/多对多？：当UDP数据报到达的目的IP是广播地址（主机部分全为1）或多播地址（224.0.0.0～239.255.255.255）时，而且在目的IP地址或端口号有多个端点时，就像每个端点传送一份数据包的复制。

使用场景：对当前网络通讯质量要求不高的时候，要求网络通讯速度尽量的快。如QQ语音、QQ视频



如何优化丢包：

1.冗余发送，将原本前后连续的两个包合成大包发送，每个包会被发送两次。所以某个包丢了仍能够复原。

2..设置定时器，超时就丢弃该帧

### UDP的头部格式

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210508100315.png" style="zoom:50%;" />

- 目标和源端口：主要告诉UDP协议应该把报文发送给哪个进程
- 包长度：该字段保存了UDP首部长度和数据的长度之和
- 校验和：校验和是为了提供可靠的UDP首部和数据而设计

### TCP、UDP协议的区别

![](https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210420152329529.png)

1. 连接

- TCP是面向连接的传输层协议，传输数据前要先建立连接
- UDP是不需要连接，即刻传输数据

2. 服务对象

- TCP是一对一的两点服务，即一条连接只有两个端点
- UDP支持一对一、一对多、多对多的交互通信

3. 可靠性

- TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达
- UDP是尽最大努力交付，不保证可靠交付数据

4. 拥塞控制、流量控制

- TCP有拥塞控制和流量控制机制，保证数据传输的安全性
- UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率

5. 首部开销

- TCP首部长度较长，会有一定的开销，首部在没有`选项`字段时是 20 个字节，如果有了选项字段则会更长。
- UDP首部只有8个字节，并且固定不变，开销较小

6. 传输方式

- TCP是流式传输，没有边界，但保证顺序和可靠
- UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序

7. 分片不同

- TCP的数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP的数据大小如果大于MTU大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，在实现可靠传输的UDP时则就需要重传所有的数据包，这样传输效率非常差，所以通常UDP的报文应该小于MTU。

### TCP和UDP应用场景

由于TCP是面向连接，能保证数据的可靠交付，因此经常用于：

- FTP 文件传输
- HTTP/HTTPS

由于UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP 等
- 视频、音频等多媒体通信
- 广播通信

> 为什么UDP 头部没有首部长度字段而TCP有？

因为TCP有可变长的选项字段，而UDP头部长度是不会变化的，无需多一个字段去记录UDP的首部长度。

> 为什么UDP头部有 包长度 字段，而TCP 头部则没有包长度 字段呢？

TCP计算负载数据长度的方式：
$$
TCP 数据的长度 = IP 总长度 - IP 首部长度 - TCP 首部长度
$$
其中 IP 总长度 和IP首部长度，在 IP 首部格式中 意志。TCP首部长度在TCP首部格式中已知，所以就可以得出TCP 数据的长度。

UDP其实也可以这样计算。

因为为了网络设备硬件设计和处理方便，首部长度需要是4字节的整数倍。如果去掉UDP「包长度」字段，那UDP首部长度就不是4字节的整数倍了，所以觉得这可能是为了补全UDP首部长度是4字节的整数倍，才补充了「包长度」字段。


### TCP三次握手与四次挥手

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210508101946.png" style="zoom:50%;" />

 **TCP三次握手的状态变迁**

一开始，客户端和服务端都处于CLOSED状态。先是服务器端主动监听某个端口，处于LISTEN状态。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903354190.png" style="zoom: 67%;" />

 

- 客户端会随机初始化序号（client_isn），将此序号置于TCP首部的（序号）字段中，同时把SYN标志位置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903370263.png" style="zoom:67%;" />

 

- 服务端收到客户端的SYN报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903383383.png" style="zoom:67%;" />

 

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。

 服务器收到客户端的应答报文后，也进入ESTABLISHED状态.

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**



**问题1、为什么要进行三次握手？不是两次、四次？**

三次握手的目的是**建立可靠的通信信道**，就是双方确认自己与对方的发送与接收是正常的。

但不是主要原因：

主要原因：

①避免历史连接

当客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：

- 一个 旧SYN报文 比 最新的 SYN 报文早到达了服务器；
- 那么此时服务器就会发送针对 旧报文 的 SYN + ACK 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。

如果是两次握手，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端有足够的上下文来判断当前连接是否是历史连接：

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接。

②同步双方初始序列号

TCP协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用:

- 接收方可以去除重复的数据;
- 接收方可以根据数据包的序列号按序接收;
- 可以标识发送出去的数据包中，哪些是已经被对方收到的;

可见，序列号在TCP连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的SYN报文的时候，需要服务端回一个ACK应答报文，表示客户端的SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能**确保双方的初始序列号能被可靠的同步**。

两次握手只保证了一方的初始化序列号能被对方成功接收，没办法保证双方的初始化序列号都被确认接收。

③避免资源浪费

 如果只有「两次握手」，当客户端的SYN 请求连接在网络中阻塞，客户端没有接收到ACK报文，就会重新发送SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK确认信号，所以每收到一个SYN就只能先主动建立一个连接，这会造成什么情况呢?│
如果客户端的SYN 阻塞了，重复发送多次SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。

总结：TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用 两次握手和四次握手的原因：

- 两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法同步双方序列号；
- 四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要更多的通信次数。

**问题2、发送的SYN和ACK是什么？**

接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。

SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

 

 

**四次挥手**

![](https://gitee.com/sun-qiao321/picture/raw/master/images/20210424223455.png)

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

【为什么握手不是两次或四次？】

既要保证可靠传输、又要保证高效的传输而做的权衡。

建立连接需要双方都通知到对方自己的初始序列号，并且对收到的序列号做回应，所以这样两个来回讲道理是需要四次握手，但是被连接的那一方可以把发送序列号和ACK合在一条发，就变成了三次。**（为什么不是四次）**

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。如果客户端的连接请求延迟抵达，两次握手的情况下会使服务端建立连接，而这一连接本该抛弃。**（为什么不是两次）**

【为什么挥手不是三次？】

只有等到Server端所有的报文都发送完了，才能发送FIN报文，因此不能一起发送 ACK+ FIN。



> 为什么 TIME_WAIT 等待的时间时 2 MSL ？

MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为TCP报文基于是IP协议的，而IP头中有一个TTL字段，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为О则数据报将被丢弃，同时发送ICMP报文通知源主机。
MSL与TTL的区别:MSL的单位是时间，而TTL是经过路由跳数。所以MSL应该要大于等于TTL消耗为0的时间，以确保报文已被自然消亡。

TIME_WAIT等待⒉倍的MSL，比较合理的解释是︰网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。
比如如果被动关闭方没有收到断开连接的最后的ACK 报文，就会触发超时重发Fin 报文，另一方接收到FIN后，会重发ACK给被动关闭方，—来一去正好2个MSL。
2MSL 的时间是从客户端接收到FIN后发送ACK开始计时的。如果在TIME-WAIT时间内，因为客户端的ACK没有传输到服务端，客户端又接收到了服务端重发的FIN报文，那么2MSL时间将重新计时。
在Linux系统里2MSL 默认是60秒，那么一个MSL也就是30秒。Linux系统停留在TIME_WAIT 的时间为固定的60秒。



> 为什么需要TIME_WAIT 状态？

主动发起关闭连接的一方，才会有 TIME_WAIT状态。

主要原因：

- 防止具有相同四元组 的 旧的数据包被收到；
- 保证被动关闭连接的一方能被正确的关闭，即保证最后的 ACK能让被动关闭方接收，从未帮助其正常关闭。

> 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP有个保活机制。这个机制的原理是这样的：

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。

如果开启了TCP保活，需要考虑以下几种情况:
第一种，对端程序是正常工作的。当TCP保活的探测报文发送给对端,对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间的到来。
第二种，对端程序崩溃并重启。当TCP保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个RST报文，这样很快就会发现TCP连接已经被重置。
第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当TCP保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该TCP连接已经死亡。



### 重传机制

- 超时重传
- 快速重传
- SACK
- D-SACK

### 如何理解TCP协议的可靠性

总结来说：TCP满足三大条件： 不丢失 不重复 按顺序到达

**发送确认**

当TCP发出一个段以后，它将发送一个确认

**数据分割**

应用数据被分割成TCP认为最合适发送的数据块，而UDP的数据报长度适中保持不变

**超时重传**

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文

**重新排序**

IP数据报可能会失序，因此必要时TCP将对数据重新排序，将正确顺序的数据交给应用层

**流量控制**

TCP会控制数据流量。TCP连接双方有固定大小的缓冲空间。流量控制功能由连接的每一端通过声明窗口的大小来提供。

**校验和**

TCP将保持它首部和数据的检验和，如果数据在传输过程中发生了变化，TCP将丢弃这个报文段、不予以确认以期待发送端超时重传。

### 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210424223833.png" style="zoom: 67%;" />

### 拥塞控制

**网络拥塞**：路由器的内存是有限的，若同一时间到达某个路由器的数据太多，这个路由器将无法接收所有的数据，只能将一部分丢弃；或者同一台路由器数据太多，后面到达的数据将要等待较长的时间才会被转发。

**拥塞控制，就是在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源**。

在发送方的`TCP`程序会跟踪和维护一个叫做**拥塞窗口**的变量，用来进行拥塞控制。拥塞窗口被称为**`cwnd`**。在`TCP`发送端，所有被发送但是还没收到确认的数据段必须落在这个窗口中，所有，当网络拥塞时，TCP程序将减小`cwnd`，而网络通畅时，增大`cwnd`，以此来控制数据发送的速率。

`TCP`调整拥塞窗口的主要算法有 **慢开始** ， **拥塞避免** 以及 **快速恢复**、 **快速重传**

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/20210424224313.png" style="zoom: 67%;" />

**慢开始** 与 **拥塞避免算法**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快速重传**  与 **快速恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

<img src="C:\Users\SQ\AppData\Roaming\Typora\typora-user-images\image-20210424225235306.png" alt="image-20210424225235306" style="zoom: 67%;" />

### TIME_WAIT作用？等待时间为什么是2MSL？

TIME_WATI状态： 主动关闭形成的。四次挥手结束之后，服务端关闭了连接，但客户端没有立即关闭，而是进入了TIME_WATI状态，时长2MSL

作用1： 防止出现先前的ACK丢失导致服务端再次发送ACK，若此时客户端已经关闭，则会导致服务端进入错误的状态。

作用2：处理先前延迟或重传的段（丢弃）。如果关闭连接后又恰巧在同一端口建立了新的连接，数据就会被错误接收。



【为什么是2MSL？】

这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。



### CLOSE_WAIT作用？

被动关闭形成的。收到FIN并返回ACK后进入CLOSE_WAIT状态，直到服务端执行了close函数，发送了FIN





### TCP如何检测断线？

对于不正常的断开有以下两种机制

1. 心跳包：每隔一段时间发送数据包，看有没有回复，没回就关闭socket
2. tcp_keepalive机制：系统层面检测，系统会自动断开长时间没有触发事件的socket



### TCP半连接  半打开 半关闭

半连接：A向B发出连接请求，B正常相应，但A不进行第三次握手，此为半连接。会造成B分配的内存资源浪费

半打开：通信双方有一方关闭，而另一方并不知情，此为半打开（不发数据无法察觉，因此可以引入心跳机制）

半关闭：A向B发送fin请求关闭，B回应之后，没有立即给A发送FIN。此时A仍能接收B的信息，但无法发送给B，此为半关闭。



### Nagle算法

网络传输中存在的微小分组，会增加拥塞出现的可能，因此可以采用Nagle算法进行解决。

该算法会收集这些小分组，并在**下一个确认到来时**以一个分组的方式发出去。

```
// MSS最大分段大小

if 有数据要发送：
   if 可用窗口大小 >= MSS and 可发送的数据 >= MSS：
        立刻发送MSS大小的数据
   else ：
       if 有未确认的数据：
            将数据放入缓存等待接收ACK
       else：
            立刻发送数据

```



【与滑窗的冲突？】

nagle为了防止大量小包的存在，普遍情况下一直有大于mss的数据发送，nagle就不管了而滑窗依然生效。



### TCP粘包/拆包

粘包：1.要发送的数据小于TCP发送缓冲区的大小，因此将多次写入缓冲区的数据一并发送（Nagle算法）  2.接收端未及时读取

拆包：1.要发送的数据大于TCP发送缓冲区的大小，因此将数据拆成多次发送 2.要发送的数据大于最大报文长度MSS

解决：

1.  发送方关闭nagle算法
2.  接收方及时处理数据
3.  数据格式化，包含固定的开始符、结束符；并在规定位置记录数据的长度



【P.S.】 UDP并不是基于字节流传输的，无论缓冲区多大都必须每条消息发送一次，因此不会出现粘包

## 网络层（Network Layer）

参考链接：

  [计网 IP 知识全家桶，45 张图一套带走](https://mp.weixin.qq.com/s/21Tk-8gxpDoH9DNWNYCWmA)

  [ping命令用得这么6，原理知道不？图解一波！](https://mp.weixin.qq.com/s/55bbQX2-SUNe6PEI9My5fA)

### 一、基本术语

1.**虚电路**（Virtual Circuit） :     在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。

2.**IP**（Internet     Protocol ） : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有     ARP，RARP，ICMP，IGMP。

3.**ARP**（Address     Resolution Protocol） : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。

4.**ICMP**（Internet Control     Message Protocol ） ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。

5.**子网掩码**（subnet mask     ） ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP     地址一起使用。

6.**CIDR**（ Classless     Inter-Domain Routing ）：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C     类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。

7.**默认路由**（default     route） ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。

8.**路由选择算法**（Virtual     Circuit） ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。

### 二、IP

**IP** 处于TCP/IP协议中的网络层：实现主机与主机之间的通信，也叫点对点通信。IP的作用是在复杂的网络环境中将数据包发送给最终目的主机。

**IP 地址**（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。

而人类为了方便记忆采用了**点分十进制**的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「.」隔开，再将每组转换成十进制。

IPv6地址有128位

 

首部：

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903566139.png" style="zoom:67%;" />

## 数据链路层（Data Link Layer）

### 一、基本术语

1.**链路**（link） ：一个结点到相邻结点的一段物理链路。

2.**数据链路**（data     link） ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。

3.循环冗余检验 CRC（Cyclic     Redundancy Check） ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。

4.**帧**（frame） ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。

5.**MTU**（Maximum Transfer     Uint ） ：最大传送单元。帧的数据部分的的长度上限。

6.**误码率     BER**（Bit     Error Rate ） ：在一段时间内，传输错误的比特占所传输比特总数的比率。

7.**PPP**（Point-to-Point     Protocol ） ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图： 

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/ppp.jpg" style="zoom: 67%;" />

8.**MAC 地址**（Media Access Control 或者 Medium Access     Control） ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP     地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址     。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/macccc.png)

9.**网桥**（bridge） ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。

10.**交换机**（switch     ） ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥

### 为什么有MAC了还需要IP地址？

**信息传输**

IP代表终点地址，MAC代表下一跳地址。IP地址的存在把网络划分成很多个子网，传输时只需要传到该子网，分发由子网内部进行，如果缺少IP地址，就需要记录每一个MAC所在的子网，路由器的内存根本支持不了这么大的计算量；但是如果缺少了MAC地址，在他刚上线的时候他连IP地址都无法获得，因为在未持有IP地址的时候，是通过MAC进行区分的。

**分层管理**

这样分层可以使网络层与链路层的协议更灵活地替换，链路层的实现不需要考虑数据之间的转发，网络层的实现不需要考虑物理层和数据链路层的影响。

**历史原因**

最初的链路层协议是和ip地址无关的，只有物理层和链路层，最初也只有集线器，没有交换机路由器，服务器之间传输数据全靠mac地址。

### 路由器、交换机、集线器、网关？

**集线器**工作在**物理层**。用途是将多个网口汇集，并进行数据广播，因此可以实现多设备通信。

**交换机**也叫交换式集线器，是集线器的升级。工作在**数据链路层**。它通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用，由于交换机根据所传递信息包的目的地址，将每一信息包独立地从源端口送至目的端口，避免了和其他端口发生碰撞。

**路由器**工作于**网络层**，主要工作就是为经过路由器的每个数据帧寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 相较于交换机（利用mac）可以得到更多的协议信息，因此路由器可以做出更加智能的转发决策。

**网关**不特指某个设备，而是指网络中完成协议转换的设施，因此也可以是某一台电脑。

## 物理层（Physical Layer）

### 一、基本术语

1.数据（data） :运送消息的实体。

2.信号（signal） ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。

3.码元（     code） ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。

4.单工（simplex     ） : 只能有一个方向的通信而没有反方向的交互。

5.半双工（half duplex     ） ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。

6.全双工（full     duplex） : 通信的双方可以同时发送和接收信息。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618903884983.png" style="zoom:50%;" />

7.失真：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率     2.信号传输距离 3.噪声干扰 4.传输媒体质量

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image002-1618903884984.png" style="zoom:80%;" />

8.奈氏准则 :     在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。

9.香农定理 ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。

10.基带信号（baseband     signal） : 来自信源的信号。指没有经过调制的数字信号或模拟信号。

11.带通（频带）信号（bandpass     signal） ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。

12.调制（modulation     ） : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。

13.信噪比（signal-to-noise     ratio ） : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。

14.信道复用（channel     multiplexing ） ：指多个用户共享同一个信道。（并不一定是同时）。

![](https://gitee.com/sun-qiao321/picture/raw/master/images/信道复用.png)

15.比特率（bit     rate ） ：单位时间（每秒）内传送的比特数。

16.波特率（baud     rate） ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。

17.复用（multiplexing） ：共享信道的方法。

18.ADSL（Asymmetric     Digital Subscriber Line ） ：非对称数字用户线。

19.光纤同轴混合网（HFC     网） :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网。

### 二、物理层的作用

  物理层主要做的事情就是 透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。

  物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。

### 三、信道复用技术

 **频分复用**

频分复用的所有主机在相同的时间占用不同的频率带宽资源。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/频分复用.png" style="zoom:50%;" />

**时分复用**

时分复用的所有主机在不同的时间占用相同的频率带宽资源。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/时分复用.png" style="zoom:50%;" />

使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。

 **统计时分复用**

是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image006.png" style="zoom:50%;" />

**波分复用**

光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。

为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 和 ![img](https://latex.codecogs.com/gif.latex?\vec{T}) 有

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png" alt="img" style="zoom:25%;" />



为了讨论方便，取 m=8，设码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。

在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" alt="img" style="zoom:25%;" />



<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" alt="img" style="zoom:25%;" />



其中 ![img](https://latex.codecogs.com/gif.latex?\vec{S%27}) 为 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 的反码。

利用上面的式子我们知道，当接收端使用码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。

码分复用需要发送的数据量为原先的 m 倍。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" alt="img" style="zoom:50%;" />