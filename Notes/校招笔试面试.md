

# 提前批

- [ ] 招银网络科技

- [ ] 





# 实习

## 网易

### 笔试

##### Volatile关键字的作用和原理

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618915628575.png" style="zoom:67%;" />

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618915657289.png" style="zoom:50%;" />

##### 新生代对象晋升到老年代的情况？

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618915697311.png" style="zoom:50%;" />

##### 统计二叉树的最优质路径

难点：自己写二叉树

输入：二叉树的数组

输出：路径数组

```java
package Test;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.*;
public class test7 {
    //通过数组创建二叉树
    private static TreeNode creatBinaryTreeByArray(int[] array,int index){
        TreeNode tn = null;
        if(index<array.length){
            int value = array[index];
            tn = new TreeNode(value);
            tn.left=creatBinaryTreeByArray(array, 2*index+1);
            tn.right=creatBinaryTreeByArray(array, 2*index+2);
            return tn;
        }
        return tn;
    }
    //找到路径
    static LinkedList<List<Integer>> res = new LinkedList<>();
    static LinkedList<Integer> path = new LinkedList<>();
    static int count = 0;
    private List<List<Integer>> pathSum(TreeNode root,int sum){
        recur(root,sum);
        return res;
    }
    void recur(TreeNode root,int target){
        if(root == null) return;
        path.add(root.val);
        target-=root.val;
        if(target==0 )
             res.add(new LinkedList<>(path));
        recur(root.left, target);
        recur(root.right, target);
        path.removeLast();
    }
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        String a = scanner.nextLine();
        String[] strArr = a.substring(1,a.length()-1).split(","); 
        int[] value = new int[strArr.length];
        for(int i = 0;i<strArr.length;i++){
            value[i] = Integer.valueOf(strArr[i]);
        }
        int target = scanner.nextInt();
        TreeNode root = creatBinaryTreeByArray(value,0);
        new test7().pathSum(root, target);
        int length = Integer.MAX_VALUE;
        for(int i = 0;i<res.size();i++){
            if(res.get(i).size()<length){
                length=res.get(i).size();
                count = i;
            }
        }
        System.out.println(res.get(count));
    }
}

//节点的定义
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

##### 波动数组，连续两个或两个以上递增或递减



##### 最大子数组序列是6的倍数

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/clip_image001-1618915808895.png" style="zoom:50%;" />

##### 最佳折扣

探讨java中Scanner类nextInt之后用nextLine无法读取输入
当用nextInt()读取缓冲区数据时，遇到回车或者空格，数据就会被读取走，但是回车符或者空格会被留下。当再调用nextLine()时，因为nextLine()是以回车符结束，当被调用后，刚好缓冲区还有被nextInt()“吃”剩下的回车符，所以还没等接着输入第二个参数，nextLine()就已经结束。因为只读取到一个回车符，所以pile的参数自然为空，从而导致后序程序出现异常。

解决方案：

把nextInt()换成nextLine()，再转换成int类型，就完美解决。

第一想法：滑动窗口

```java
package Test;
import java.util.Arrays;
import java.util.Scanner;
public class test8 {
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int s = Integer.parseInt(scanner.nextLine());
        int bonus = Integer.parseInt(scanner.nextLine());
        String[] str = scanner.nextLine().split(" ");
        int[] value = new int[str.length];
        for(int i = 0;i<str.length;i++){
            value[i] = Integer.parseInt(str[i]);
        }
        Arrays.sort(value);
        int count = Integer.MAX_VALUE;
        int sum = 0;
        int i = 0;
        for(int j = 0;j<value.length;j++){
            sum += value[j];
            while(sum>=s){
                count = Math.min(sum,count);
                sum -= value[i++];
            }
        }
        System.out.println(count-bonus);
    }
}
```

存在bug ：输入 49 53 52 48 输出 91 不可行

## 字节跳动

### 一面

##### 堆和栈的区别

- 堆内存是是Java内存中的一种，它的作用是用于存储Java中的对象和数组，当我们new一个对象或者创建一个数组的时候，就会在堆内存中开辟一段空间给它，用于存放。

 

- 堆内存的特点是什么？

第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队，好，你先买票。

 

第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。

 

- new对象在堆中如何分配？

由Java虚拟机的自动垃圾回收器来管理

 

- 栈内存是Java的另一种内存，主要是用来执行程序用的，比如：基本类型的变量和对象的引用变量

 

- 栈内存的特点

第一点：栈内存就好像一个矿泉水瓶，像里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出

 

第二点：存取速度比堆要快，仅次于寄存器，栈数据可以共享，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性

 

- 栈内存分配机制

栈内存可以称为一级缓存，由垃圾回收器自动回收

 

栈和堆的区别

JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。

 

差异

1.堆内存用来存放由new创建的对象和数组。

2.栈内存用来存放方法或者局部变量等

3.堆是先进先出，后进后出

4.栈是后进先出，先进后出

 

相同

1.都是属于Java内存的一种

2.系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它

##### TreeMap和HashMap的联系和区别

区别：

①定义

先看HashMap的定义：

public class HashMap<K,V> extends AbstractMap<K,V>
   implements Map<K,V>, Cloneable, Serializable

再看TreeMap的定义：

public class TreeMap<K,V>
   extends AbstractMap<K,V>
   implements NavigableMap<K,V>, Cloneable, java.io.Serializable

从类的定义来看，HashMap和TreeMap都继承自AbstractMap，不同的是HashMap实现的是Map接口，而TreeMap实现的是NavigableMap接口。NavigableMap是SortedMap的一种，实现了对Map中key的排序。

②排序区别

TreeMap输出是排好序的，而HashMap不是。

③性能区别

HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。

另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。

HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。

TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。

相同点：两者都不允许重复的Key，两者都不是线程安全的。

##### TreeMap和HashMap的时间复杂度是多少？

HashMap O(1) TreeMap O(log n)

<img src="https://gitee.com/sun-qiao321/picture/raw/master/images/image-20210420185510973.png" style="zoom:50%;" />

##### HashMap默认加载因子为什么选择0.75？

 HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。

 

public HashMap(int initialCapacity, float loadFactor) 

HashMap除了默认的无参构造函数之外，还可以接受两个参数initialCapacity和loadFactor。

HashMap的底层结构是Node的数组：

transient Node<K,V>[] table

initialCapacity就是这个table的初始容量。如果大家不传initialCapacity，HashMap提供了一个默认的值：

static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

当HashMap中存储的数据过多的时候，table数组就会被装满，这时候就需要扩容，HashMap的扩容是以2的倍数来进行的。而loadFactor就指定了什么时候需要进行扩容操作。默认的loadFactor是0.75。

static final float DEFAULT_LOAD_FACTOR = 0.75f;

 

默认加载因子选择0.75的原因：提高空间利用率和减少成本的折中，主要是泊松分布，0.75的话碰撞最小。

##### static修饰的变量是线程安全的吗？

（一）静态变量：线程非安全

  1、静态变量：使用static关键字定义的变量。static可以修饰变量和方法，也有static静态代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被**类的所有实例共享**。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。

  用public修饰的static成员变量和成员方法本质是变量和全局方法，当声明它的类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。

  2、静态变量使用的场景：

  (1)对象间共享值时

  (2)方便访问变量时

  3、静态方法使用注意事项：

  (1)不能在静态方法内使用非静态变量，即不能直接访问所属类的实例变量；

  (2)不能在静态方法内直接调用非静态方法；

  (3)静态方法中不能使用this和super关键字；

## 美团

介绍项目：毕设项目问了很多，实习经历问了很多

有没有用过其他语言。

java C++ matlab  区别

java多继承 ： 继承多个类，这两个类再继承一个类，形成菱形的继承结构，很容易造成概念混淆；多态方面不好处理

Spring  IOC  AOP介绍下

AOP提到动态代理方式实现，动态代理怎么实现

IOC怎么注入的，

static变量能够注入进去吗？

不能，因为static是属于类的属性，在类加载时就存在，不好通过实例来注入

如果非要注入static 怎么搞，通过@PostConstruct注解，在注入前会执行该方法，在方法中注入。

第一步：写注解@Component 使当前类成为一个bean对象。(@Controller,@service都行)

第二步：写个static的变量

第三步：写个@PostConstruct注解注释的方法，在这个方法里，将自动注入的值赋值给定义的static变量

第四步：static变量替代自动注入在static方法里面使用

```java
@Component
public class DSHWechatApiUtil extends DSHBaseController {    
    @Autowired    
    private IThirdPartyAuthDao thirdPartyAuthDao;

    @Autowired
    private static IThirdPartyAuthDao staticThirdPartyAuthDao;
    
    @PostConstruct
    public void init() {
        staticThirdPartyAuthDao = thirdPartyAuthDao;
    }

    public static JSONObject getAuthorizerToken(String componentAccessToken, String authorizerAppid, String authorizerRefreshToken) {
        JSONObject returnObject = new JSONObject();
        try {
            if (DSHUtils.isEmpty(componentAccessToken)) {
                componentAccessToken = staticThirdPartyAuthDao.selectWechatValue(DSHConstants.WECHAT_PARAMS.COMPONENT_ACCESS_TOKEN);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return returnObject;
    }
}
```

@PostConstruct注解作用：是Java EE 5引入的注解，Spring允许开发者在受管Bean中使用它。当DI容器实例化当前受管Bean时，@PostConstruct注解的方法会被自动触发，从而完成一些初始化工作。
注意:

- 只有一个方法可以使用此注释进行注解；
- 被注解方法不得有任何参数；
- 被注解方法返回值为void；
- 被注解方法不得抛出已检查异常；
- 被注解方法需是非静态方法；
- 此方法只会被执行一次；

```java
/*给出一组区间，请合并所有重叠的区间。
*例如，
*给出[1,3],[2,6],[8,10],[15,18],
*返回[1,6],[8,10],[15,18].*/
import java.util.*;
public class Solution {

    public ArrayList<Interval> merge(ArrayList<Interval> intervals){
        ArrayList<Interval> result = new ArrayList<>();
        if(intervals.size() == 0) return result;
        Collections.sort(intervals,new Comparator<Interval>(){
            public int compare(Interval i1,Interval i2){
                return i1.start - i2.start;
            }
        });
        result.add(intervals.get(0));
        int end = intervals.get(0).end;
        for(int i = 1;i<intervals.size();i++){
            if( intervals.get(i).start <= end && end<= intervals.get(i).end ){
                Interval temp = result.get(result.size()-1);
                result.remove(result.size()-1);
                temp.end = intervals.get(i).end;
                result.add(temp);
            }else if(end > intervals.get(i).end){
                continue;
            }
            if(result.get(result.size()-1).end < intervals.get(i).start){
                result.add(intervals.get(i));
            }
            end =result.get(result.size()-1).end;
        }
        return result;
    }
    
}
```



RESTful调用和 RPC调用有什么区别？如果让你设计一个RPC服务治理框架你会设计那些模块？是否了解过Service Mesh，如果了解Service Mesh是用来解决什么问题的？

 

1、RESTful是一种软件架构风格，用于约束客户端和服务器交互，满足这些约束条件和原则的应用程序或设计就是 RESTful。比如HTTP协议使用同一个URL地址，通过GET，POST，PUT，DELETE等方式实现查询、提交、删除数据。RPC是远程过程调用，是用于解决分布式系统服务间调用的一种方式。RPC采用客户端与服务端模式，双方通过约定的接口（常见为通过IDL定义或者是代码定义）以类似本地方法调用的方式来进行交互，客户端根据约定传输调用函数+参数给服务端（一般是网络传输TCP/UDP），服务端处理完按照约定将返回值返回给客户端。

重点为RESTful HTTP的约束风格，RPC调用模型。

1、可分为两大部分RPC +服务治理

RPC部分 = IDL  +客户端/服务端实现层 +协议层 +数据传输层

服务治理 =服务管理（注册中心） +服务监控 +服务容灾 +服务鉴权

2、 Service Mesh为了解决传统微服务框架"胖客户端"方式，引入的如下问题：

与业务无关的服务治理逻辑与业务代码强耦合，框架、SDK的升级与业务代码强绑定，多语言的胖客户端支持起来性价比极低。

 

 

请描述避免多线程竞争时有哪些手段？

1) 不可变对象；

2) 互斥锁；

3) ThreadLocal 对象；

4) CAS；

 

请简述HTTP的5个常用Method及其含义，以及5个常用Status Code及其含义？HTTP与HTTPS的区别是什么，简述一下HTTPS的实现原理。

HTTP常用Method列举：

\1. HEAD --- 获取报文头部信息。

\2. GET --- 返回报文主体信息，不会对数据产生任何影响。

\3. POST --- 传输实体主体，用于给服务器发送数据，如表单提交等

\4. OPTIONS --- 询问支持方法

\5. PUT --- 传输文件，报文主体中包含文件内容，保存到指定URI资源的存放位置

\6. DELETE --- 删除指定URI下的指定资源。

\-------------------------------------------------------

常用Status Code

\* 200 OK 标识请求已经完成。

\* 403 Forbidden 没有访问资源的权限

\* 404 NOT FOUND 找不到请求资源

\* 500 Not Implement 服务端不支持或不能被处理。

\* 502 Bad Getaway 网关错误

———————————————————

HTTP与HTTPS区别：

HTTPS是HTTP经由加入SSL层来提高数据传输的安全性。其中SSL依靠证书来验证服务器的身份，并对浏览器与服务器之间的 通信进行数据加密。HTTP不适合传输敏感信息。

HTTPs实现原理：

。发起请求：客户端通过TCP和服务器建立连接后，发出一个请求证书的消息给到服务器。

。证书返回：服务器端在收到请求后回应客户端并且返回证书



### 美团点评

###### 判断二叉树是否对称

给定一棵二叉树，判断琪是否是自身的镜像（即：是否对称）
例如：下面这棵二叉树是对称的
   1
  / \
 2  2
 / \  / \
3 4 4 3
下面这棵二叉树不对称。
  1
  / \
 2  2
  \  \
  3  3
备注：
希望你可以用递归和迭代两种方法解决这个问题

```java
    public boolean travel(TreeNode root){
        if(root == null) {
            return false;
        }
        compare(root.left,root.right);
    }
    public boolean compare(TreeNode left,TreeNode right){
        if(left == null && right != null) return false;
        else if(left != null && right == null) return false;
        else if(left.val != right.val) return false;
        boolean bleft = compare(left.left,right.right);
        boolean bright = compare(left.right,right.left);
        return bleft && bright;
    }
```

###### 翻转字符串（2）

给一个字符类型的数组chas和一个整数size，请把大小为size的左半区整体右移到右半区，右半区整体移动到左边。

```java
import java.util.*;


public class Solution {
    /**
     * reverse string II
     * @param str string字符串 the string
     * @param size int整型 the size
     * @return string字符串
     */
    public String reverseStringII (String str, int size) {
        // write code here
        int length = str.length();
        if(size > length) {
            return str;
        }
        StringBuilder sb = new StringBuilder();
        sb.append(str.substring(size,length)).append(str.substring(0,size));
        return sb.toString();
    }
}
```

###### 设计LRU缓存结构

设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能

- set(key, value)：将记录(key, value)插入该结构
- get(key)：返回key对应的value值

[要求]

1. set和get方法的时间复杂度为O(1)
2. 某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。
3. 当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。

若opt=1，接下来两个整数x, y，表示set(x, y)
若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1
对于每个操作2，输出一个答案

示例1

输入

```
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3
```

输出

```
[1,-1]
```

说明

```
第一次操作后：最常使用的记录为("1", 1)
第二次操作后：最常使用的记录为("2", 2)，("1", 1)变为最不常用的
第三次操作后：最常使用的记录为("3", 2)，("1", 1)还是最不常用的
第四次操作后：最常用的记录为("1", 1)，("2", 2)变为最不常用的
第五次操作后：大小超过了3，所以移除此时最不常使用的记录("2", 2)，加入记录("4", 4)，并且为最常使用的记录，然后("3", 2)变为最不常使用的记录
```

```
import java.util.*;


public class Solution {
    /**
     * lru design
     * @param operators int整型二维数组 the ops
     * @param k int整型 the k
     * @return int整型一维数组
     */
    public int[] LRU (int[][] operators, int k) {
        // write code here
        
    }
}
```

###### 链表中倒数第k个结点

输入一个链表，输出该链表中倒数第k个结点。

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
import java.util.*;
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        ListNode temp1 = head;
        ListNode temp2 = head;
        for(int i = 0;i<k;i++){
            if(temp2 == null) return null;
            temp2 = temp2.next;
        }
        while(temp2 != null){
            temp1 = temp1.next;
            temp2 = temp2.next;
        }
        return temp1;
    }
}
```



## 阿里

#### 蚂蚁金服

hashCode() 和 equal() 的区别

HashMap() 的底层原理

给一个k 查找值的过程中调用了哪些函数

编程题：数对和

## 华为编程题

### 汽水瓶

> 有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？

```java
import java.util.*;
public class Main{
    public static int Drink(int n) {
        if(n == 0) {
            return 0;
        }
        int k = 0;
        int result = 0;
        while (n>0) {
            n = n +k;
            k = n%3;
            n = n/3;
            result += n;
        }
        if(k==2) {
            return result + 1;
        }else {
            return result;
        }
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int num = scanner.nextInt();
            if(num !=0) {
                System.out.println(Drink(num));
            }
        }
        scanner.close();
    }
}
```

**迭代法**

```java
import java.util.*;
public class Main{
    public static int Drink(int n) {
        if (n == 1 ) return 0;
        if (n == 2 ) return 1;
        return n/3 + Drink(n%3 + n/3);
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int num = scanner.nextInt();
            if(num !=0) {
                System.out.println(Drink(num));
            }
        }
        scanner.close();
    }
}
```

### 明明的随机数

> 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)。

```java
import java.util.Iterator;
import java.util.Scanner;
import java.util.TreeSet;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while (in.hasNext()) {
			int n = in.nextInt(); 
			TreeSet<Integer> ts = new TreeSet<Integer>(); 
			for (int i = 0; i < n; i++) {
				ts.add(in.nextInt());	//树在插入时进行排序.
			}
			// 输出所有值
			Iterator it = ts.iterator();
			while (it.hasNext()) {
				System.out.println(it.next());
			}
		}
	}
}
```

### 进制转换

> 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        while (sc.hasNext()){
            StringBuffer sb=new StringBuffer();
            sb.append(sc.next());
            String str=sb.reverse().substring(0,sb.length()-2);
            char ch[]=str.toCharArray();
            int sum=0;
            for(int i=0;i<ch.length;i++){
                if(ch[i]>='A'&&ch[i]<='F'){
                    sum+=(Integer.valueOf(ch[i])-55)*Math.pow(16,i);
                }else {
                    sum+=(Integer.valueOf(ch[i])-48)*Math.pow(16,i);
                }
            }
            System.out.println(sum);
        }
    }
}
```

### 删数

> 有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

```java
import java.util.*;
public class Main{
    public static int Josepfu(int n,int m){
        int x = 0;
        for (int i=2;i<=n;i++){
            x = (x + m)%i;
        }
        return x;
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = 0;
        while(in.hasNext()){
           n = in.nextInt();
           System.out.println(Josepfu(n,3));
        }
    }
}
```

### 字符集合

> 输入一个字符串，求出该字符串包含的字符集合

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
           Set<Character> a = new HashSet<>();
           StringBuffer s = new StringBuffer();
           char[] res = in.next().toCharArray();
            for(int i = 0 ;i<res.length;i++){
                if(a.add(res[i])) s.append(res[i]);
            }
            System.out.println(s);
        }
    }
}
```



